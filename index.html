<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#2196F3">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Pet Clicker">
    <meta name="description" content="Professional pet training clicker with ultra-low latency audio for dogs and cats">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIlBldCBUcmFpbmluZyBDbGlja2VyIiwKICAic2hvcnRfbmFtZSI6ICJQZXRDbGlja2VyIiwKICAiZGVzY3JpcHRpb24iOiAiUHJvZmVzc2lvbmFsIHBldCB0cmFpbmluZyBjbGlja2VyIHdpdGggdWx0cmEtbG93IGxhdGVuY3kgYXVkaW8iLAogICJzdGFydF91cmwiOiAiLyIsCiAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgIm9yaWVudGF0aW9uIjogInBvcnRyYWl0IiwKICAidGhlbWVfY29sb3IiOiAiIzIxOTZGMyIsCiAgImJhY2tncm91bmRfY29sb3IiOiAiI2ZmZmZmZiIsCiAgImNhdGVnb3JpZXMiOiBbInBldHMiLCAidHJhaW5pbmciLCAidG9vbHMiXSwKICAibGFuZyI6ICJlbiIsCiAgImljb25zIjogWwogICAgewogICAgICAic3JjIjogImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UazJJaUJvWldsbmFIUTlJakU1TmlJZ2RtbGxkMEp2ZUQwaU1DQXdJREU1TmlBeE9UWWlJR1pwYkd3OUlpTXlNVGsyUmpNaVBnb2dJRHhqYVhKamJHVWdZM2c5SWprNElpQmplVDBpT1RnaUlISTlJekl3SWlCbWFXeHNQU0lqWm1abUlpOCtDaUFnUEdOcGNtTnNaU0JqZUQwaU9UZ2lJR041UFNJNFppSWdjajBpTVRVaUlHWnBiR3c5SWlNeU1UazJSak1pTHo0S1BDOXpkbWMrIiwKICAgICAgInNpemVzIjogIjE5MngxOTIiLAogICAgICAidHlwZSI6ICJpbWFnZS9zdmcreG1sIiwKICAgICAgInB1cnBvc2UiOiAiYW55IG1hc2thYmxlIgogICAgfSwKICAgIHsKICAgICAgInNyYyI6ICJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlOVEV5SWlCb1pXbG5hSFE5SWpVeE1pSWdkbWxsZDBKdmVEMGlNQ0F3SURRNE1DQTBPREFpSUdacGJHdzlJaU15TVRrMlJqTWlQZ29nSUR4amFYSmpiR1VnWTNnOUlqSTBNQ0lnWTNrOUlqSTBNQ0lnY2owaU1UQXdJaUJtYVd4c1BTSWpabVptSWk4K0NpQWdQR05wY21Oc1pTQmplRDBpTWpRd0lpQmplVDBpTVRrd0lpQnlQU0kzTUNJZ1ptbHNiRDBpSXpJeE9UWkdNeUl2UGdvOEwzTjJaejQiLAogICAgICAic2l6ZXMiOiAiNTEyeDUxMiIsCiAgICAgICJ0eXBlIjogImltYWdlL3N2Zyt4bWwiLAogICAgICAicHVycG9zZSI6ICJhbnkgbWFza2FibGUiCiAgICB9CiAgXSwKICAic2hvcnRjdXRzIjogWwogICAgewogICAgICAibmFtZSI6ICJRdWljayBDbGljayIsCiAgICAgICJ1cmwiOiAiLz9xdWljaz10cnVlIiwKICAgICAgImRlc2NyaXB0aW9uIjogIk9wZW4gY2xpY2tlciByZWFkeSB0byB1c2UiCiAgICB9CiAgXQp9">
    
    <!-- iOS Icons -->
    <link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTk2IiBoZWlnaHQ9IjE5NiIgdmlld0JveD0iMCAwIDE5NiAxOTYiIGZpbGw9IiMyMTk2RjMiPgogIDxjaXJjbGUgY3g9Ijk4IiBjeT0iOTgiIHI9IjIwIiBmaWxsPSIjZmZmIi8+CiAgPGNpcmNsZSBjeD0iOTgiIGN5PSI4ZiIgcj0iMTUiIGZpbGw9IiMyMTk2RjMiLz4KPC9zdmc+">
    
    <title>Pet Training Clicker</title>
    
    <style>
        /* CSS Variables - Design System */
        :root {
            /* Primary Colors */
            --primary-blue: #2196F3;
            --primary-blue-dark: #1976D2;
            --primary-blue-light: #E3F2FD;
            
            /* Neutral Colors */
            --white: #FFFFFF;
            --gray-50: #FAFAFA;
            --gray-100: #F5F5F5;
            --gray-200: #EEEEEE;
            --gray-400: #BDBDBD;
            --gray-600: #757575;
            --gray-900: #212121;
            
            /* Feedback Colors */
            --success-green: #4CAF50;
            --warning-orange: #FF9800;
            --error-red: #F44336;
            
            /* High Contrast Mode */
            --hc-background: #000000;
            --hc-foreground: #FFFFFF;
            --hc-accent: #FFFF00;
            
            /* Typography */
            --font-primary: -apple-system, BlinkMacSystemFont, 'Segoe UI', 
                            Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            --text-xs: 12px;
            --text-sm: 14px;
            --text-base: 16px;
            --text-lg: 18px;
            --text-xl: 24px;
            --text-2xl: 32px;
        }

        /* Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-primary);
            background: var(--gray-50);
            color: var(--gray-900);
            line-height: 1.5;
            overflow-x: hidden;
            -webkit-tap-highlight-color: transparent;
        }

        /* Main Container */
        .container {
            width: 100%;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
        }

        /* App Header */
        .app-header {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        .app-title {
            font-size: var(--text-lg);
            font-weight: 600;
            color: var(--gray-600);
            margin-bottom: 4px;
        }

        .app-subtitle {
            font-size: var(--text-sm);
            color: var(--gray-400);
        }

        /* Mobile Optimization Styles */
        
        /* Enhanced Touch Targets */
        .click-button {
            width: min(300px, 80vw);
            height: min(300px, 80vw);
            max-height: 50vh;
            
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--primary-blue-dark) 100%);
            border: none;
            border-radius: 50%;
            
            color: var(--white);
            font-size: var(--text-xl);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
            
            cursor: pointer;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            
            box-shadow: 
                0 8px 16px rgba(33, 150, 243, 0.3),
                0 2px 4px rgba(0, 0, 0, 0.1);
            
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            
            /* Enhanced for mobile touch */
            min-height: 44px; /* iOS accessibility minimum */
            min-width: 44px;
        }

        /* Enhanced Active State for Mobile */
        .click-button:active,
        .click-button.clicking {
            transform: scale(0.95);
            box-shadow: 
                0 4px 8px rgba(33, 150, 243, 0.4),
                0 1px 2px rgba(0, 0, 0, 0.2);
        }

        /* iOS Specific Optimizations */
        @supports (-webkit-touch-callout: none) {
            .click-button {
                -webkit-appearance: none;
                -webkit-user-select: none;
                -webkit-touch-callout: none;
                -webkit-tap-highlight-color: rgba(0,0,0,0);
            }
            
            /* Prevent iOS zoom on focus */
            input, select, textarea {
                font-size: 16px;
            }
        }

        /* Android Specific Optimizations */
        @media screen and (-webkit-min-device-pixel-ratio: 0) {
            .click-button {
                /* Improve touch response on Android */
                will-change: transform;
            }
        }

        /* Enhanced Control Buttons for Mobile */
        .control-button {
            width: 56px;
            height: 56px;
            border-radius: 12px;
            border: 1px solid var(--gray-200);
            background: var(--white);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            font-size: var(--text-sm);
            font-weight: 500;
            
            /* Mobile touch optimizations */
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 44px;
            min-width: 44px;
        }

        /* Enhanced Volume Slider for Mobile */
        .volume-slider {
            width: 100px;
            height: 44px; /* Larger touch target */
            background: transparent;
            border-radius: 22px;
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            position: relative;
        }

        .volume-slider::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 6px;
            background: var(--gray-200);
            border-radius: 3px;
            transform: translateY(-50%);
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--primary-blue);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            position: relative;
            z-index: 2;
        }

        .volume-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--primary-blue);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* Mobile Landscape Optimizations */
        @media (orientation: landscape) and (max-height: 500px) {
            .container {
                padding: 10px;
            }
            
            .app-header {
                position: static;
                margin-bottom: 10px;
            }
            
            .app-title {
                font-size: var(--text-base);
            }
            
            .app-subtitle {
                display: none; /* Hide subtitle in tight landscape */
            }
            
            .click-button {
                width: min(200px, 40vw);
                height: min(200px, 60vh);
                font-size: var(--text-lg);
            }
            
            .control-panel {
                margin-top: 20px;
                gap: 12px;
            }
            
            .status-panel {
                font-size: 10px;
                gap: 15px;
            }
        }

        /* Haptic Feedback Enhancement Indicator */
        .haptic-pulse {
            animation: haptic-pulse 0.1s ease-out;
        }

        @keyframes haptic-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        /* Loading State for Mobile */
        .mobile-loading {
            pointer-events: none;
            opacity: 0.7;
        }

        .mobile-loading .click-button {
            background: var(--gray-400);
        }

        /* PWA Specific Styles */
        
        /* Install Button */
        .install-button {
            background: linear-gradient(135deg, var(--success-green) 0%, #388E3C 100%);
            color: var(--white);
            border: none;
        }

        .install-button:hover {
            background: linear-gradient(135deg, #388E3C 0%, var(--success-green) 100%);
        }

        /* Update Notification */
        .update-notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--primary-blue);
            color: var(--white);
            padding: 16px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
        }

        .update-content {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: var(--text-sm);
        }

        .update-button, .dismiss-button {
            background: var(--white);
            color: var(--primary-blue);
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: var(--text-xs);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .update-button:hover {
            background: var(--gray-100);
        }

        .dismiss-button {
            background: transparent;
            color: var(--white);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .dismiss-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        @keyframes slideIn {
            from {
                transform: translateX(-50%) translateY(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }

        /* Offline Mode Styles */
        .offline .click-button {
            background: linear-gradient(135deg, var(--gray-400) 0%, var(--gray-600) 100%);
        }

        .offline .app-header::after {
            content: ' (Offline)';
            color: var(--warning-orange);
            font-size: var(--text-sm);
        }

        /* PWA Installed Styles */
        .pwa-installed .app-header {
            padding-top: env(safe-area-inset-top, 0);
        }

        /* Standalone mode optimizations */
        @media (display-mode: standalone) {
            body {
                padding-top: env(safe-area-inset-top, 0);
                padding-bottom: env(safe-area-inset-bottom, 0);
            }
            
            .container {
                min-height: calc(100vh - env(safe-area-inset-top, 0) - env(safe-area-inset-bottom, 0));
            }
        }

        /* Ripple Effect */
        .click-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .click-button.clicking::before {
            animation: ripple 0.6s linear;
        }

        /* Control Panel */
        .control-panel {
            display: flex;
            gap: 16px;
            justify-content: center;
            margin-top: 40px;
            flex-wrap: wrap;
        }

        .control-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            min-width: 80px;
        }

        .control-label {
            font-size: var(--text-sm);
            color: var(--gray-600);
            font-weight: 500;
        }

        .control-button {
            width: 56px;
            height: 56px;
            border-radius: 12px;
            border: 1px solid var(--gray-200);
            background: var(--white);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            font-size: var(--text-sm);
            font-weight: 500;
        }

        .control-button:hover {
            border-color: var(--primary-blue);
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2);
        }

        .control-button.active {
            background: var(--primary-blue);
            border-color: var(--primary-blue);
            color: var(--white);
        }

        /* Volume Slider */
        .volume-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .volume-slider {
            width: 100px;
            height: 6px;
            background: var(--gray-200);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-blue);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .volume-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-blue);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .volume-value {
            font-size: var(--text-xs);
            color: var(--gray-400);
            min-width: 30px;
            text-align: center;
        }

        /* Status Display */
        .status-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            font-size: var(--text-xs);
            color: var(--gray-600);
            text-align: center;
        }

        .status-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .status-value {
            font-weight: 600;
            color: var(--gray-900);
        }

        .status-good { color: var(--success-green); }
        .status-warning { color: var(--warning-orange); }
        .status-error { color: var(--error-red); }

        /* Screen Reader Only */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* High Contrast Mode */
        .high-contrast {
            background: var(--hc-background);
            color: var(--hc-foreground);
        }

        .high-contrast .click-button {
            background: var(--hc-accent);
            color: var(--hc-background);
            border: 3px solid var(--hc-foreground);
        }

        .high-contrast .control-button {
            background: var(--hc-background);
            color: var(--hc-foreground);
            border: 2px solid var(--hc-foreground);
        }

        .high-contrast .control-button.active {
            background: var(--hc-accent);
            color: var(--hc-background);
        }

        /* Animations */
        @keyframes click-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes ripple {
            0% {
                width: 0;
                height: 0;
                opacity: 1;
            }
            100% {
                width: 400px;
                height: 400px;
                opacity: 0;
            }
        }

        /* Responsive Design */
        @media (min-width: 481px) and (orientation: landscape) {
            .container {
                flex-direction: row;
                gap: 40px;
                padding: 30px;
            }

            .main-content {
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .control-panel {
                flex-direction: column;
                margin-top: 0;
                margin-left: 0;
            }

            .app-header {
                position: static;
                transform: none;
                margin-bottom: 20px;
            }
        }

        @media (min-width: 769px) {
            .container {
                max-width: 600px;
                margin: 0 auto;
                flex-direction: column;
                padding: 40px;
            }

            .click-button {
                width: 320px;
                height: 320px;
                max-height: none;
            }

            .control-panel {
                flex-direction: row;
                gap: 24px;
                margin-top: 50px;
            }

            .status-panel {
                position: static;
                transform: none;
                margin-top: 30px;
                padding: 16px;
                background: var(--white);
                border-radius: 8px;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            }
        }

        /* Loading State */
        .loading {
            opacity: 0.7;
            pointer-events: none;
        }

        .loading-spinner {
            width: 24px;
            height: 24px;
            border: 2px solid var(--gray-200);
            border-top: 2px solid var(--primary-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- App Header -->
        <header class="app-header">
            <h1 class="app-title">Pet Training Clicker</h1>
            <p class="app-subtitle">Professional clicker for dogs & cats</p>
        </header>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Primary Click Button -->
            <button 
                id="click-button" 
                class="click-button" 
                aria-label="Pet training clicker - Press to make click sound"
                role="button"
            >
                CLICK
            </button>

            <!-- Control Panel -->
            <div class="control-panel">
                <!-- Sound Type Selector -->
                <div class="control-item">
                    <label class="control-label" for="sound-selector">Sound</label>
                    <select id="sound-selector" class="control-button" style="width: 80px; text-align: center;">
                        <option value="metal">Metal</option>
                        <option value="plastic">Plastic</option>
                        <option value="box">Box</option>
                    </select>
                </div>

                <!-- Volume Control -->
                <div class="control-item">
                    <label class="control-label" for="volume-slider">Volume</label>
                    <div class="volume-container">
                        <input 
                            type="range" 
                            id="volume-slider" 
                            class="volume-slider"
                            min="0" 
                            max="1" 
                            step="0.1" 
                            value="0.8"
                            aria-label="Volume control"
                        >
                        <span id="volume-value" class="volume-value">80%</span>
                    </div>
                </div>

                <!-- Settings Button -->
                <div class="control-item">
                    <span class="control-label">Settings</span>
                    <button 
                        id="settings-button" 
                        class="control-button"
                        aria-label="Open settings"
                    >
                        ⚙️
                    </button>
                </div>
            </div>
        </main>

        <!-- Status Panel -->
        <div class="status-panel">
            <div class="status-item">
                <span class="status-label">Clicks</span>
                <span id="click-count" class="status-value">0</span>
            </div>
            <div class="status-item">
                <span class="status-label">Latency</span>
                <span id="latency-display" class="status-value">--ms</span>
            </div>
            <div class="status-item">
                <span class="status-label">Status</span>
                <span id="audio-status" class="status-value">Ready</span>
            </div>
        </div>

        <!-- Screen Reader Announcements -->
        <div id="sr-announcer" class="sr-only" aria-live="polite" aria-atomic="true"></div>
    </div>

    <script>
        // PWA Service Worker Registration and Management
        class PWAManager {
            constructor() {
                this.isOnline = navigator.onLine;
                this.deferredPrompt = null;
                this.isInstalled = false;
                this.updateAvailable = false;
                
                this.init();
            }

            async init() {
                // Register service worker
                await this.registerServiceWorker();
                
                // Setup install prompt handling
                this.setupInstallPrompt();
                
                // Setup online/offline detection
                this.setupOnlineDetection();
                
                // Setup update detection
                this.setupUpdateDetection();
                
                // Check if already installed
                this.checkInstallStatus();
            }

            async registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    try {
                        // Register inline service worker
                        const swCode = this.generateServiceWorkerCode();
                        const blob = new Blob([swCode], { type: 'application/javascript' });
                        const swUrl = URL.createObjectURL(blob);
                        
                        const registration = await navigator.serviceWorker.register(swUrl);
                        console.log('Service Worker registered successfully');
                        
                        // Setup update listener
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    this.updateAvailable = true;
                                    this.showUpdatePrompt();
                                }
                            });
                        });
                        
                        return registration;
                    } catch (error) {
                        console.log('Service Worker registration failed:', error);
                    }
                }
            }

            generateServiceWorkerCode() {
                return `
                    const CACHE_NAME = 'pet-clicker-v1.0.0';
                    const AUDIO_CACHE = 'pet-clicker-audio-v1.0.0';
                    
                    // Install event - cache core resources
                    self.addEventListener('install', (event) => {
                        event.waitUntil(
                            caches.open(CACHE_NAME).then((cache) => {
                                // Cache the main page and essential resources
                                return cache.add(new Request(self.location.href));
                            })
                        );
                        self.skipWaiting();
                    });
                    
                    // Activate event - clean up old caches
                    self.addEventListener('activate', (event) => {
                        event.waitUntil(
                            caches.keys().then((cacheNames) => {
                                return Promise.all(
                                    cacheNames.map((cacheName) => {
                                        if (cacheName !== CACHE_NAME && cacheName !== AUDIO_CACHE) {
                                            return caches.delete(cacheName);
                                        }
                                    })
                                );
                            })
                        );
                        self.clients.claim();
                    });
                    
                    // Fetch event - serve from cache, fallback to network
                    self.addEventListener('fetch', (event) => {
                        if (event.request.method !== 'GET') return;
                        
                        event.respondWith(
                            caches.match(event.request).then((response) => {
                                if (response) {
                                    return response;
                                }
                                
                                return fetch(event.request).then((response) => {
                                    // Don't cache non-successful responses
                                    if (!response || response.status !== 200 || response.type !== 'basic') {
                                        return response;
                                    }
                                    
                                    const responseToCache = response.clone();
                                    caches.open(CACHE_NAME).then((cache) => {
                                        cache.put(event.request, responseToCache);
                                    });
                                    
                                    return response;
                                });
                            }).catch(() => {
                                // Return offline page for navigation requests
                                if (event.request.mode === 'navigate') {
                                    return new Response(
                                        '<h1>Offline</h1><p>Pet Clicker is cached and ready to use offline!</p>',
                                        { headers: { 'Content-Type': 'text/html' } }
                                    );
                                }
                            })
                        );
                    });
                `;
            }

            setupInstallPrompt() {
                // Listen for beforeinstallprompt event
                window.addEventListener('beforeinstallprompt', (e) => {
                    e.preventDefault();
                    this.deferredPrompt = e;
                    this.showInstallButton();
                });

                // Listen for app installation
                window.addEventListener('appinstalled', () => {
                    this.isInstalled = true;
                    this.hideInstallButton();
                    this.showInstallSuccess();
                });
            }

            setupOnlineDetection() {
                window.addEventListener('online', () => {
                    this.isOnline = true;
                    this.updateOnlineStatus();
                });

                window.addEventListener('offline', () => {
                    this.isOnline = false;
                    this.updateOnlineStatus();
                });

                this.updateOnlineStatus();
            }

            setupUpdateDetection() {
                // Check for updates periodically
                setInterval(() => {
                    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                        navigator.serviceWorker.controller.postMessage({ command: 'checkForUpdates' });
                    }
                }, 30000); // Check every 30 seconds
            }

            checkInstallStatus() {
                // Check if running as PWA
                const isStandalone = window.matchMedia('(display-mode: standalone)').matches ||
                                   window.navigator.standalone ||
                                   document.referrer.includes('android-app://');
                
                if (isStandalone) {
                    this.isInstalled = true;
                    document.body.classList.add('pwa-installed');
                }
            }

            async promptInstall() {
                if (!this.deferredPrompt) return false;

                this.deferredPrompt.prompt();
                const result = await this.deferredPrompt.userChoice;
                
                if (result.outcome === 'accepted') {
                    console.log('PWA install accepted');
                    this.isInstalled = true;
                } else {
                    console.log('PWA install declined');
                }
                
                this.deferredPrompt = null;
                return result.outcome === 'accepted';
            }

            showInstallButton() {
                const installButton = this.createInstallButton();
                if (installButton && !document.querySelector('.install-button')) {
                    const controlPanel = document.querySelector('.control-panel');
                    if (controlPanel) {
                        controlPanel.appendChild(installButton);
                    }
                }
            }

            createInstallButton() {
                const installItem = document.createElement('div');
                installItem.className = 'control-item';
                
                const label = document.createElement('span');
                label.className = 'control-label';
                label.textContent = 'Install';
                
                const button = document.createElement('button');
                button.className = 'control-button install-button';
                button.setAttribute('aria-label', 'Install app');
                button.innerHTML = '📱';
                
                button.addEventListener('click', async () => {
                    const installed = await this.promptInstall();
                    if (installed) {
                        installItem.remove();
                    }
                });
                
                installItem.appendChild(label);
                installItem.appendChild(button);
                
                return installItem;
            }

            hideInstallButton() {
                const installButton = document.querySelector('.install-button');
                if (installButton) {
                    installButton.closest('.control-item')?.remove();
                }
            }

            showInstallSuccess() {
                // Show success message
                if (window.petClicker) {
                    window.petClicker.announceToScreenReader('App installed successfully! You can now use the clicker offline.');
                }
            }

            showUpdatePrompt() {
                // Show update notification
                const updateNotification = this.createUpdateNotification();
                document.body.appendChild(updateNotification);
            }

            createUpdateNotification() {
                const notification = document.createElement('div');
                notification.className = 'update-notification';
                notification.innerHTML = `
                    <div class="update-content">
                        <span>New version available!</span>
                        <button class="update-button">Update</button>
                        <button class="dismiss-button">Later</button>
                    </div>
                `;
                
                notification.querySelector('.update-button').addEventListener('click', () => {
                    this.applyUpdate();
                    notification.remove();
                });
                
                notification.querySelector('.dismiss-button').addEventListener('click', () => {
                    notification.remove();
                });
                
                return notification;
            }

            async applyUpdate() {
                if ('serviceWorker' in navigator) {
                    const registration = await navigator.serviceWorker.getRegistration();
                    if (registration && registration.waiting) {
                        registration.waiting.postMessage({ command: 'skipWaiting' });
                        window.location.reload();
                    }
                }
            }

            updateOnlineStatus() {
                const statusDisplay = document.getElementById('audio-status');
                if (statusDisplay && !this.isOnline) {
                    statusDisplay.textContent = 'Offline';
                    statusDisplay.className = 'status-value status-warning';
                } else if (statusDisplay && this.isOnline && window.petClicker?.isAudioInitialized) {
                    statusDisplay.textContent = 'Ready';
                    statusDisplay.className = 'status-value status-good';
                }
                
                // Update body class for offline styling
                document.body.classList.toggle('offline', !this.isOnline);
            }

            // Cache management
            async clearCache() {
                if ('caches' in window) {
                    const cacheNames = await caches.keys();
                    await Promise.all(cacheNames.map(name => caches.delete(name)));
                    console.log('Cache cleared');
                }
            }

            async getCacheSize() {
                if ('storage' in navigator && 'estimate' in navigator.storage) {
                    const estimate = await navigator.storage.estimate();
                    return {
                        usage: estimate.usage,
                        quota: estimate.quota,
                        usageInMB: Math.round(estimate.usage / 1024 / 1024 * 100) / 100
                    };
                }
                return null;
            }
        }

        // Pet Training Clicker - Stage 4 Implementation with PWA Features
        class MobileOptimizer {
            constructor() {
                this.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                this.isAndroid = /Android/.test(navigator.userAgent);
                this.devicePixelRatio = window.devicePixelRatio || 1;
                this.touchStartTime = 0;
                this.lastTouchEnd = 0;
                this.hapticSupported = 'vibrate' in navigator;
                
                // Touch event tracking
                this.activeTouch = null;
                this.touchMoved = false;
                
                this.init();
            }

            init() {
                this.setupViewport();
                this.setupTouchOptimizations();
                this.setupHapticFeedback();
                this.setupOrientationHandling();
                this.setupIOSSpecific();
                this.setupAndroidSpecific();
            }

            setupViewport() {
                // Optimize viewport for mobile
                let viewport = document.querySelector('meta[name="viewport"]');
                if (viewport) {
                    viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover';
                }

                // Prevent zoom on iOS
                document.addEventListener('gesturestart', (e) => e.preventDefault());
                document.addEventListener('gesturechange', (e) => e.preventDefault());
                document.addEventListener('gestureend', (e) => e.preventDefault());
            }

            setupTouchOptimizations() {
                // Prevent double-tap zoom
                document.addEventListener('touchend', (e) => {
                    const now = Date.now();
                    if (now - this.lastTouchEnd <= 300) {
                        e.preventDefault();
                    }
                    this.lastTouchEnd = now;
                }, false);

                // Optimize touch event handling
                document.addEventListener('touchstart', (e) => {
                    this.touchStartTime = performance.now();
                    this.touchMoved = false;
                }, { passive: true });

                document.addEventListener('touchmove', (e) => {
                    this.touchMoved = true;
                }, { passive: true });
            }

            setupHapticFeedback() {
                // Enhanced haptic patterns
                this.hapticPatterns = {
                    click: [20], // Short pulse for press
                    clack: [10], // Shorter pulse for release
                    error: [50, 50, 50], // Triple pulse for errors
                    success: [30, 10, 30] // Double pulse for success
                };
            }

            setupOrientationHandling() {
                // Handle orientation changes
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => {
                        this.handleOrientationChange();
                    }, 500); // Delay to allow layout to settle
                });

                // Handle resize events
                window.addEventListener('resize', this.debounce(() => {
                    this.handleResize();
                }, 250));
            }

            setupIOSSpecific() {
                if (!this.isIOS) return;

                // Prevent iOS scroll bounce
                document.body.style.overscrollBehavior = 'none';
                
                // Handle iOS safe areas
                this.handleIOSSafeAreas();
                
                // Prevent iOS selection
                document.body.style.webkitUserSelect = 'none';
                document.body.style.webkitTouchCallout = 'none';
            }

            setupAndroidSpecific() {
                if (!this.isAndroid) return;

                // Optimize for Android chrome
                document.body.style.overscrollBehavior = 'contain';
                
                // Improve touch responsiveness
                document.body.style.touchAction = 'manipulation';
            }

            handleOrientationChange() {
                // Adjust layout for new orientation
                const container = document.querySelector('.container');
                if (container) {
                    container.classList.toggle('landscape-mode', window.innerWidth > window.innerHeight);
                }

                // Scroll to top to reset viewport
                window.scrollTo(0, 0);
            }

            handleResize() {
                // Handle dynamic viewport changes (like iOS Safari URL bar)
                this.updateViewportHeight();
            }

            updateViewportHeight() {
                // Set CSS custom property for real viewport height
                const vh = window.innerHeight * 0.01;
                document.documentElement.style.setProperty('--vh', `${vh}px`);
            }

            handleIOSSafeAreas() {
                // Add CSS for safe area handling
                const style = document.createElement('style');
                style.textContent = `
                    @supports (padding: max(0px)) {
                        .container {
                            padding-top: max(20px, env(safe-area-inset-top));
                            padding-bottom: max(20px, env(safe-area-inset-bottom));
                            padding-left: max(20px, env(safe-area-inset-left));
                            padding-right: max(20px, env(safe-area-inset-right));
                        }
                    }
                `;
                document.head.appendChild(style);
            }

            triggerHaptic(pattern = 'click') {
                if (!this.hapticSupported) return;

                const hapticPattern = this.hapticPatterns[pattern] || this.hapticPatterns.click;
                
                try {
                    navigator.vibrate(hapticPattern);
                } catch (error) {
                    console.log('Haptic feedback not available');
                }
            }

            // Enhanced touch event helpers
            isValidTouch(touch, element) {
                const rect = element.getBoundingClientRect();
                return (
                    touch.clientX >= rect.left &&
                    touch.clientX <= rect.right &&
                    touch.clientY >= rect.top &&
                    touch.clientY <= rect.bottom
                );
            }

            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }
        }

        class AudioEngine {
            constructor() {
                this.audioContext = null;
                this.audioBuffers = new Map();
                this.isInitialized = false;
                this.audioPool = [];
                this.poolSize = 8;
                this.currentPoolIndex = 0;
                this.volume = 0.8;
                this.selectedSound = 'metal';
                this.useHTML5Fallback = false;
                this.html5AudioPool = [];
                
                // Mobile detection
                this.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                this.isAndroid = /Android/.test(navigator.userAgent);
                this.keepAliveInterval = null;
            }

            async initialize() {
                try {
                    // Create AudioContext with optimal latency settings
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        latencyHint: 'interactive',
                        sampleRate: 44100
                    });

                    console.log(`AudioContext created - Base latency: ${(this.audioContext.baseLatency * 1000).toFixed(1)}ms`);

                    // Load clicker sounds
                    await this.loadAllSounds();
                    
                    // Initialize audio pool for rapid clicking
                    this.initializeAudioPool();
                    
                    // Setup mobile-specific workarounds
                    await this.setupMobileWorkarounds();
                    
                    this.isInitialized = true;
                    return true;
                    
                } catch (error) {
                    console.warn('Web Audio API failed, falling back to HTML5 Audio:', error);
                    this.initializeHTML5Fallback();
                    return false;
                }
            }

            async loadAllSounds() {
                // Generate synthetic clicker sounds - both press (click) and release (clack)
                const sounds = {
                    'metal-click': this.generateMetalClick(),
                    'metal-clack': this.generateMetalClack(),
                    'plastic-click': this.generatePlasticClick(),
                    'plastic-clack': this.generatePlasticClack(),
                    'box-click': this.generateBoxClick(),
                    'box-clack': this.generateBoxClack()
                };

                for (const [name, audioBuffer] of Object.entries(sounds)) {
                    this.audioBuffers.set(name, audioBuffer);
                }
            }

            generateMetalClick() {
                // Generate sharp metal clicker PRESS sound (2-6kHz, fast attack)
                const sampleRate = this.audioContext.sampleRate;
                const duration = 0.08; // 80ms
                const length = sampleRate * duration;
                const buffer = this.audioContext.createBuffer(1, length, sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < length; i++) {
                    const t = i / sampleRate;
                    // Sharp attack with multiple frequencies for metallic sound
                    const envelope = Math.exp(-t * 25); // Fast decay
                    const noise = (Math.random() - 0.5) * 0.3;
                    const tone1 = Math.sin(2 * Math.PI * 3000 * t) * 0.4;
                    const tone2 = Math.sin(2 * Math.PI * 4500 * t) * 0.3;
                    const tone3 = Math.sin(2 * Math.PI * 6000 * t) * 0.2;
                    
                    data[i] = (tone1 + tone2 + tone3 + noise) * envelope;
                }
                return buffer;
            }

            generateMetalClack() {
                // Generate metal clicker RELEASE sound (lower pitch, softer)
                const sampleRate = this.audioContext.sampleRate;
                const duration = 0.06; // 60ms - shorter than click
                const length = sampleRate * duration;
                const buffer = this.audioContext.createBuffer(1, length, sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < length; i++) {
                    const t = i / sampleRate;
                    // Softer envelope and lower frequencies
                    const envelope = Math.exp(-t * 30); // Faster decay
                    const noise = (Math.random() - 0.5) * 0.2;
                    const tone1 = Math.sin(2 * Math.PI * 2200 * t) * 0.3; // Lower than press
                    const tone2 = Math.sin(2 * Math.PI * 3200 * t) * 0.2;
                    const tone3 = Math.sin(2 * Math.PI * 4800 * t) * 0.15;
                    
                    data[i] = (tone1 + tone2 + tone3 + noise) * envelope * 0.7; // Quieter
                }
                return buffer;
            }

            generatePlasticClick() {
                // Generate softer plastic clicker PRESS sound (1-4kHz, medium attack)
                const sampleRate = this.audioContext.sampleRate;
                const duration = 0.1; // 100ms
                const length = sampleRate * duration;
                const buffer = this.audioContext.createBuffer(1, length, sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < length; i++) {
                    const t = i / sampleRate;
                    const envelope = Math.exp(-t * 15); // Medium decay
                    const noise = (Math.random() - 0.5) * 0.2;
                    const tone1 = Math.sin(2 * Math.PI * 2000 * t) * 0.5;
                    const tone2 = Math.sin(2 * Math.PI * 3000 * t) * 0.3;
                    
                    data[i] = (tone1 + tone2 + noise) * envelope * 0.8;
                }
                return buffer;
            }

            generatePlasticClack() {
                // Generate plastic clicker RELEASE sound
                const sampleRate = this.audioContext.sampleRate;
                const duration = 0.08; // 80ms
                const length = sampleRate * duration;
                const buffer = this.audioContext.createBuffer(1, length, sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < length; i++) {
                    const t = i / sampleRate;
                    const envelope = Math.exp(-t * 18); // Slightly faster decay
                    const noise = (Math.random() - 0.5) * 0.15;
                    const tone1 = Math.sin(2 * Math.PI * 1600 * t) * 0.4; // Lower frequencies
                    const tone2 = Math.sin(2 * Math.PI * 2400 * t) * 0.25;
                    
                    data[i] = (tone1 + tone2 + noise) * envelope * 0.6; // Quieter
                }
                return buffer;
            }

            generateBoxClick() {
                // Generate loud box clicker PRESS sound (2-8kHz, very sharp attack)
                const sampleRate = this.audioContext.sampleRate;
                const duration = 0.11; // 110ms
                const length = sampleRate * duration;
                const buffer = this.audioContext.createBuffer(1, length, sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < length; i++) {
                    const t = i / sampleRate;
                    const envelope = Math.exp(-t * 20); // Sharp decay
                    const noise = (Math.random() - 0.5) * 0.4;
                    const tone1 = Math.sin(2 * Math.PI * 2500 * t) * 0.4;
                    const tone2 = Math.sin(2 * Math.PI * 4000 * t) * 0.3;
                    const tone3 = Math.sin(2 * Math.PI * 6000 * t) * 0.2;
                    const tone4 = Math.sin(2 * Math.PI * 8000 * t) * 0.1;
                    
                    data[i] = (tone1 + tone2 + tone3 + tone4 + noise) * envelope;
                }
                return buffer;
            }

            generateBoxClack() {
                // Generate box clicker RELEASE sound
                const sampleRate = this.audioContext.sampleRate;
                const duration = 0.09; // 90ms
                const length = sampleRate * duration;
                const buffer = this.audioContext.createBuffer(1, length, sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < length; i++) {
                    const t = i / sampleRate;
                    const envelope = Math.exp(-t * 22); // Sharp decay
                    const noise = (Math.random() - 0.5) * 0.3;
                    const tone1 = Math.sin(2 * Math.PI * 2000 * t) * 0.35; // Lower than press
                    const tone2 = Math.sin(2 * Math.PI * 3200 * t) * 0.25;
                    const tone3 = Math.sin(2 * Math.PI * 4800 * t) * 0.15;
                    const tone4 = Math.sin(2 * Math.PI * 6400 * t) * 0.08;
                    
                    data[i] = (tone1 + tone2 + tone3 + tone4 + noise) * envelope * 0.75; // Quieter
                }
                return buffer;
            }

            initializeAudioPool() {
                this.audioPool = [];
                for (let i = 0; i < this.poolSize; i++) {
                    const gainNode = this.audioContext.createGain();
                    gainNode.connect(this.audioContext.destination);
                    this.audioPool.push({
                        gainNode: gainNode,
                        isPlaying: false
                    });
                }
            }

            async setupMobileWorkarounds() {
                if (this.isIOS) {
                    await this.setupIOSWorkarounds();
                }
                
                if (this.isAndroid) {
                    this.setupAndroidWorkarounds();
                }

                this.setupUserGestureHandler();
            }

            async setupIOSWorkarounds() {
                try {
                    // Enable audio in iOS silent mode by playing silent audio
                    const silentBuffer = this.audioContext.createBuffer(1, 1, this.audioContext.sampleRate);
                    const source = this.audioContext.createBufferSource();
                    source.buffer = silentBuffer;
                    source.connect(this.audioContext.destination);
                    source.start();
                    
                    console.log('iOS silent mode workaround applied');
                } catch (error) {
                    console.warn('iOS workaround failed:', error);
                }
            }

            setupAndroidWorkarounds() {
                // Keep AudioContext alive on Android Chrome
                this.keepAliveInterval = setInterval(() => {
                    if (this.audioContext && this.audioContext.state === 'running') {
                        // Play silent tone to prevent context suspension
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        gainNode.gain.setValueAtTime(0.001, this.audioContext.currentTime);
                        oscillator.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.01);
                    }
                }, 25000); // Every 25 seconds
            }

            setupUserGestureHandler() {
                const unlockAudio = async () => {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                        console.log('AudioContext resumed');
                    }
                    
                    // Remove listeners after first interaction
                    document.removeEventListener('touchstart', unlockAudio);
                    document.removeEventListener('click', unlockAudio);
                };

                document.addEventListener('touchstart', unlockAudio);
                document.addEventListener('click', unlockAudio);
            }

            playClick() {
                if (this.useHTML5Fallback) {
                    return this.playClickHTML5();
                }

                if (!this.isInitialized || !this.audioContext) {
                    console.warn('Audio not initialized');
                    return false;
                }

                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }

                // Get next available audio source from pool
                const audioSource = this.getNextAudioSource();
                if (!audioSource) {
                    console.warn('All audio sources busy');
                    return false;
                }

                const buffer = this.audioBuffers.get(`${this.selectedSound}-click`);
                if (!buffer) {
                    console.warn('Audio buffer not found:', `${this.selectedSound}-click`);
                    return false;
                }

                // Create and configure buffer source
                const bufferSource = this.audioContext.createBufferSource();
                bufferSource.buffer = buffer;
                
                // Set volume
                audioSource.gainNode.gain.setValueAtTime(
                    this.volume, 
                    this.audioContext.currentTime
                );
                
                // Connect and play
                bufferSource.connect(audioSource.gainNode);
                bufferSource.start(0);
                
                // Mark source as playing and clean up when done
                audioSource.isPlaying = true;
                bufferSource.onended = () => {
                    audioSource.isPlaying = false;
                };

                return true;
            }

            playClack() {
                if (this.useHTML5Fallback) {
                    return this.playClackHTML5();
                }

                if (!this.isInitialized || !this.audioContext) {
                    console.warn('Audio not initialized');
                    return false;
                }

                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }

                // Get next available audio source from pool
                const audioSource = this.getNextAudioSource();
                if (!audioSource) {
                    console.warn('All audio sources busy');
                    return false;
                }

                const buffer = this.audioBuffers.get(`${this.selectedSound}-clack`);
                if (!buffer) {
                    console.warn('Audio buffer not found:', `${this.selectedSound}-clack`);
                    return false;
                }

                // Create and configure buffer source
                const bufferSource = this.audioContext.createBufferSource();
                bufferSource.buffer = buffer;
                
                // Set volume (slightly quieter for release sound)
                audioSource.gainNode.gain.setValueAtTime(
                    this.volume * 0.85, 
                    this.audioContext.currentTime
                );
                
                // Connect and play
                bufferSource.connect(audioSource.gainNode);
                bufferSource.start(0);
                
                // Mark source as playing and clean up when done
                audioSource.isPlaying = true;
                bufferSource.onended = () => {
                    audioSource.isPlaying = false;
                };

                return true;
            }

            getNextAudioSource() {
                // Find next available source in pool
                for (let i = 0; i < this.poolSize; i++) {
                    const index = (this.currentPoolIndex + i) % this.poolSize;
                    if (!this.audioPool[index].isPlaying) {
                        this.currentPoolIndex = (index + 1) % this.poolSize;
                        return this.audioPool[index];
                    }
                }
                return null; // All sources busy
            }

            initializeHTML5Fallback() {
                console.log('Initializing HTML5 Audio fallback');
                this.useHTML5Fallback = true;
                this.html5AudioPool = [];
                
                // Create synthetic click sounds for HTML5 fallback
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const sounds = {
                    'metal': this.generateMetalClick.call({audioContext}),
                    'plastic': this.generatePlasticClick.call({audioContext}),
                    'box': this.generateBoxClick.call({audioContext})
                };

                // Convert to data URLs for HTML5 Audio (simplified for demo)
                for (let i = 0; i < this.poolSize; i++) {
                    this.html5AudioPool.push({
                        isPlaying: false,
                        audio: null
                    });
                }
                
                this.isInitialized = true;
            }

            playClickHTML5() {
                // Simplified HTML5 fallback - just log for demo
                console.log(`HTML5 Audio: Playing ${this.selectedSound} click at volume ${this.volume}`);
                return true;
            }

            playClackHTML5() {
                // Simplified HTML5 fallback - just log for demo
                console.log(`HTML5 Audio: Playing ${this.selectedSound} clack at volume ${this.volume * 0.85}`);
                return true;
            }

            setVolume(volume) {
                this.volume = Math.max(0, Math.min(1, volume));
            }

            setSelectedSound(soundType) {
                if (this.audioBuffers.has(`${soundType}-click`) && this.audioBuffers.has(`${soundType}-clack`)) {
                    this.selectedSound = soundType;
                    return true;
                }
                return false;
            }

            cleanup() {
                if (this.keepAliveInterval) {
                    clearInterval(this.keepAliveInterval);
                }
                if (this.audioContext) {
                    this.audioContext.close();
                }
            }
        }

        class PetClicker {
            constructor() {
                this.clickCount = 0;
                this.volume = 0.8;
                this.selectedSound = 'metal';
                this.isClicking = false;
                this.latencyMeasurements = [];
                this.audioEngine = new AudioEngine();
                this.mobileOptimizer = new MobileOptimizer();
                this.pwaManager = new PWAManager();
                this.isAudioInitialized = false;
                
                // Enhanced touch handling
                this.touchStartTime = 0;
                this.touchId = null;
                this.pressTimer = null;
                
                // Offline capabilities
                this.offlineMode = false;
                this.syncQueue = [];
                
                // DOM Elements
                this.clickButton = null;
                this.volumeSlider = null;
                this.volumeValue = null;
                this.soundSelector = null;
                this.clickCountDisplay = null;
                this.latencyDisplay = null;
                this.audioStatusDisplay = null;
                this.srAnnouncer = null;
                
                this.init();
            }

            async init() {
                this.setupElements();
                this.bindEnhancedEvents();
                this.updateDisplay();
                
                // Initialize audio system
                await this.initializeAudio();
                
                // Setup mobile optimizations
                this.setupMobileFeatures();
                
                // Setup PWA features
                this.setupPWAFeatures();
                
                // Load saved settings
                this.loadSettings();
                
                this.announceToScreenReader('Pet training clicker ready');
            }

            setupPWAFeatures() {
                // Setup offline detection
                window.addEventListener('online', () => {
                    this.offlineMode = false;
                    this.syncOfflineData();
                });
                
                window.addEventListener('offline', () => {
                    this.offlineMode = true;
                });
                
                // Setup before unload to save data
                window.addEventListener('beforeunload', () => {
                    this.saveSettings();
                });
                
                // Setup visibility change for battery optimization
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.saveSettings();
                        if (this.audioEngine.audioContext) {
                            this.audioEngine.audioContext.suspend();
                        }
                    } else {
                        if (this.audioEngine.audioContext && this.audioEngine.audioContext.state === 'suspended') {
                            this.audioEngine.audioContext.resume();
                        }
                    }
                });
            }

            loadSettings() {
                try {
                    const settings = localStorage.getItem('pet-clicker-settings');
                    if (settings) {
                        const parsed = JSON.parse(settings);
                        
                        // Restore volume
                        if (parsed.volume !== undefined) {
                            this.volume = parsed.volume;
                            this.volumeSlider.value = this.volume;
                            this.audioEngine.setVolume(this.volume);
                            this.updateVolumeDisplay();
                        }
                        
                        // Restore sound type
                        if (parsed.selectedSound) {
                            this.selectedSound = parsed.selectedSound;
                            this.soundSelector.value = this.selectedSound;
                            this.audioEngine.setSelectedSound(this.selectedSound);
                        }
                        
                        // Restore click count if recent session
                        if (parsed.clickCount && parsed.lastSession) {
                            const lastSession = new Date(parsed.lastSession);
                            const now = new Date();
                            const hoursSinceLastSession = (now - lastSession) / (1000 * 60 * 60);
                            
                            // Restore count if last session was within 24 hours
                            if (hoursSinceLastSession < 24) {
                                this.clickCount = parsed.clickCount;
                                this.updateDisplay();
                            }
                        }
                    }
                } catch (error) {
                    console.log('Could not load settings:', error);
                }
            }

            saveSettings() {
                try {
                    const settings = {
                        volume: this.volume,
                        selectedSound: this.selectedSound,
                        clickCount: this.clickCount,
                        lastSession: new Date().toISOString()
                    };
                    
                    localStorage.setItem('pet-clicker-settings', JSON.stringify(settings));
                } catch (error) {
                    console.log('Could not save settings:', error);
                }
            }

            syncOfflineData() {
                // Sync any offline data when back online
                if (this.syncQueue.length > 0) {
                    console.log('Syncing offline data...');
                    // In a real app, this might sync to a server
                    this.syncQueue = [];
                }
            }

            setupMobileFeatures() {
                // Update viewport height for mobile
                this.mobileOptimizer.updateViewportHeight();
                
                // Add mobile-specific classes
                if (this.mobileOptimizer.isIOS) {
                    document.body.classList.add('ios-device');
                }
                if (this.mobileOptimizer.isAndroid) {
                    document.body.classList.add('android-device');
                }
            }

            bindEnhancedEvents() {
                // Enhanced touch events for better mobile experience
                this.clickButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleEnhancedTouchStart(e);
                }, { passive: false });
                
                this.clickButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handleEnhancedTouchEnd(e);
                }, { passive: false });

                this.clickButton.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    this.handleTouchCancel(e);
                }, { passive: false });

                this.clickButton.addEventListener('touchmove', (e) => {
                    this.handleTouchMove(e);
                }, { passive: true });
                
                // Mouse events for desktop
                this.clickButton.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.handleClickStart();
                });
                
                this.clickButton.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    this.handleClickEnd();
                });

                // Prevent context menu
                this.clickButton.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });

                // Enhanced volume control
                this.volumeSlider.addEventListener('input', (e) => {
                    this.volume = parseFloat(e.target.value);
                    this.audioEngine.setVolume(this.volume);
                    this.updateVolumeDisplay();
                    
                    // Haptic feedback for volume changes on mobile
                    if (this.mobileOptimizer.isIOS || this.mobileOptimizer.isAndroid) {
                        this.mobileOptimizer.triggerHaptic('click');
                    }
                });

                // Sound selection with haptic feedback
                this.soundSelector.addEventListener('change', (e) => {
                    this.selectedSound = e.target.value;
                    this.audioEngine.setSelectedSound(this.selectedSound);
                    this.announceToScreenReader(`Sound changed to ${this.selectedSound} clicker`);
                    
                    // Play preview sound
                    setTimeout(() => {
                        this.audioEngine.playClick();
                    }, 100);
                });

                // Enhanced keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    this.handleKeyboard(e);
                });

                // Prevent zoom on double tap
                this.preventDoubleZoom();
            }

            handleEnhancedTouchStart(event) {
                if (this.isClicking || !this.isAudioInitialized) return;
                
                const touch = event.touches[0];
                if (!touch) return;

                // Store touch info
                this.touchId = touch.identifier;
                this.touchStartTime = performance.now();
                
                // Validate touch is within button bounds
                if (!this.mobileOptimizer.isValidTouch(touch, this.clickButton)) {
                    return;
                }

                this.handleClickStart();
            }

            handleEnhancedTouchEnd(event) {
                if (!this.isClicking) return;

                // Ensure this is the same touch that started
                const touch = event.changedTouches[0];
                if (touch && touch.identifier !== this.touchId) return;

                this.handleClickEnd();
                this.touchId = null;
            }

            handleTouchCancel(event) {
                // Handle touch interruption (like incoming call)
                if (this.isClicking) {
                    this.handleClickEnd();
                }
                this.touchId = null;
            }

            handleTouchMove(event) {
                if (!this.isClicking || !this.touchId) return;

                const touch = Array.from(event.touches).find(t => t.identifier === this.touchId);
                if (!touch) return;

                // Cancel if touch moves too far from button
                if (!this.mobileOptimizer.isValidTouch(touch, this.clickButton)) {
                    this.handleTouchCancel(event);
                }
            }

            preventDoubleZoom() {
                let lastTouchEnd = 0;
                document.addEventListener('touchend', (e) => {
                    const now = Date.now();
                    if (now - lastTouchEnd <= 300) {
                        e.preventDefault();
                    }
                    lastTouchEnd = now;
                }, false);
            }

            async initializeAudio() {
                try {
                    this.audioStatusDisplay.textContent = 'Loading...';
                    this.audioStatusDisplay.className = 'status-value status-warning';
                    
                    const success = await this.audioEngine.initialize();
                    
                    if (success) {
                        this.audioStatusDisplay.textContent = 'Ready';
                        this.audioStatusDisplay.className = 'status-value status-good';
                        this.isAudioInitialized = true;
                        console.log('Audio system initialized successfully');
                    } else {
                        this.audioStatusDisplay.textContent = 'Fallback';
                        this.audioStatusDisplay.className = 'status-value status-warning';
                        this.isAudioInitialized = true;
                        console.log('Audio system using HTML5 fallback');
                    }
                } catch (error) {
                    this.audioStatusDisplay.textContent = 'Error';
                    this.audioStatusDisplay.className = 'status-value status-error';
                    console.error('Audio initialization failed:', error);
                }
            }

            setupElements() {
                this.clickButton = document.getElementById('click-button');
                this.volumeSlider = document.getElementById('volume-slider');
                this.volumeValue = document.getElementById('volume-value');
                this.soundSelector = document.getElementById('sound-selector');
                this.clickCountDisplay = document.getElementById('click-count');
                this.latencyDisplay = document.getElementById('latency-display');
                this.audioStatusDisplay = document.getElementById('audio-status');
                this.srAnnouncer = document.getElementById('sr-announcer');

                // Set initial values
                this.volumeSlider.value = this.volume;
                this.soundSelector.value = this.selectedSound;
                this.audioEngine.setVolume(this.volume);
                this.audioEngine.setSelectedSound(this.selectedSound);
                
                // Mobile-specific element optimizations
                if (this.mobileOptimizer.isIOS || this.mobileOptimizer.isAndroid) {
                    // Improve touch targets
                    this.clickButton.style.minHeight = '44px';
                    this.clickButton.style.minWidth = '44px';
                    
                    // Optimize volume slider for mobile
                    this.volumeSlider.style.minHeight = '44px';
                }
            }

            bindEvents() {
                // Primary click handlers
                this.clickButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleClickStart();
                });
                
                this.clickButton.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.handleClickStart();
                });

                this.clickButton.addEventListener('touchend', () => {
                    this.handleClickEnd();
                });
                
                this.clickButton.addEventListener('mouseup', () => {
                    this.handleClickEnd();
                });

                // Prevent context menu on long press
                this.clickButton.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });

                // Volume control
                this.volumeSlider.addEventListener('input', (e) => {
                    this.volume = parseFloat(e.target.value);
                    this.audioEngine.setVolume(this.volume);
                    this.updateVolumeDisplay();
                });

                // Sound selection
                this.soundSelector.addEventListener('change', (e) => {
                    this.selectedSound = e.target.value;
                    this.audioEngine.setSelectedSound(this.selectedSound);
                    this.announceToScreenReader(`Sound changed to ${this.selectedSound} clicker`);
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    this.handleKeyboard(e);
                });

                // Prevent zooming on double tap
                let lastTouchEnd = 0;
                document.addEventListener('touchend', (e) => {
                    const now = (new Date()).getTime();
                    if (now - lastTouchEnd <= 300) {
                        e.preventDefault();
                    }
                    lastTouchEnd = now;
                }, false);
            }

            handleClickStart() {
                if (this.isClicking || !this.isAudioInitialized) return;
                
                const startTime = performance.now();
                this.isClicking = true;
                
                // Enhanced visual feedback
                this.clickButton.classList.add('clicking');
                
                // Enhanced haptic feedback with patterns
                if (this.mobileOptimizer.hapticSupported) {
                    this.mobileOptimizer.triggerHaptic('click');
                }
                
                // Add haptic pulse animation
                this.clickButton.classList.add('haptic-pulse');
                setTimeout(() => {
                    this.clickButton.classList.remove('haptic-pulse');
                }, 100);
                
                // Play PRESS sound (click)
                const audioSuccess = this.audioEngine.playClick();
                
                if (audioSuccess) {
                    // Update counter only if audio played successfully
                    this.clickCount++;
                    this.updateDisplay();
                    
                    // Measure actual audio latency
                    const endTime = performance.now();
                    this.recordLatency(endTime - startTime);
                    
                    // Update status
                    this.audioStatusDisplay.textContent = 'Pressed';
                    this.audioStatusDisplay.className = 'status-value status-good';
                    
                } else {
                    // Audio failed - enhanced error feedback
                    this.audioStatusDisplay.textContent = 'Error';
                    this.audioStatusDisplay.className = 'status-value status-error';
                    
                    // Error haptic pattern
                    this.mobileOptimizer.triggerHaptic('error');
                }
                
                // Screen reader feedback (throttled)
                if (this.clickCount % 10 === 0) {
                    this.announceToScreenReader(`${this.clickCount} clicks completed`);
                }
            }

            handleClickEnd() {
                if (!this.isClicking) return;
                
                this.isClicking = false;
                this.clickButton.classList.remove('clicking');
                
                // Enhanced haptic feedback for release
                if (this.mobileOptimizer.hapticSupported) {
                    this.mobileOptimizer.triggerHaptic('clack');
                }
                
                // Play RELEASE sound (clack)
                const audioSuccess = this.audioEngine.playClack();
                
                if (audioSuccess) {
                    // Update status
                    this.audioStatusDisplay.textContent = 'Released';
                    this.audioStatusDisplay.className = 'status-value status-good';
                    
                    // Success haptic pattern
                    this.mobileOptimizer.triggerHaptic('success');
                    
                    // Reset status after short delay
                    setTimeout(() => {
                        if (this.isAudioInitialized) {
                            this.audioStatusDisplay.textContent = 'Ready';
                            this.audioStatusDisplay.className = 'status-value status-good';
                        }
                    }, 300);
                } else {
                    // Audio failed
                    this.audioStatusDisplay.textContent = 'Error';
                    this.audioStatusDisplay.className = 'status-value status-error';
                    this.mobileOptimizer.triggerHaptic('error');
                }
            }

            handleKeyboard(event) {
                // Space bar or Enter to click
                if (event.code === 'Space' || event.code === 'Enter') {
                    event.preventDefault();
                    if (!this.isClicking) {
                        this.handleClickStart();
                        
                        // Auto-release after realistic delay for keyboard (like physical clicker)
                        setTimeout(() => this.handleClickEnd(), 150);
                    }
                }
                
                // Volume controls
                if (event.code === 'ArrowUp') {
                    event.preventDefault();
                    this.adjustVolume(0.1);
                }
                
                if (event.code === 'ArrowDown') {
                    event.preventDefault();
                    this.adjustVolume(-0.1);
                }

                // Sound type cycling
                if (event.code === 'KeyM') {
                    event.preventDefault();
                    this.cycleSoundType();
                }
            }

            cycleSoundType() {
                const sounds = ['metal', 'plastic', 'box'];
                const currentIndex = sounds.indexOf(this.selectedSound);
                const nextIndex = (currentIndex + 1) % sounds.length;
                
                this.selectedSound = sounds[nextIndex];
                this.soundSelector.value = this.selectedSound;
                this.audioEngine.setSelectedSound(this.selectedSound);
                this.announceToScreenReader(`Sound changed to ${this.selectedSound} clicker`);
            }

            adjustVolume(delta) {
                this.volume = Math.max(0, Math.min(1, this.volume + delta));
                this.volumeSlider.value = this.volume;
                this.audioEngine.setVolume(this.volume);
                this.updateVolumeDisplay();
                this.announceToScreenReader(`Volume ${Math.round(this.volume * 100)}%`);
            }

            recordLatency(latency) {
                this.latencyMeasurements.push(latency);
                if (this.latencyMeasurements.length > 50) {
                    this.latencyMeasurements.shift();
                }
            }

            getAverageLatency() {
                if (this.latencyMeasurements.length === 0) return 0;
                const sum = this.latencyMeasurements.reduce((a, b) => a + b, 0);
                return sum / this.latencyMeasurements.length;
            }

            updateDisplay() {
                // Update click count
                this.clickCountDisplay.textContent = this.clickCount;
                
                // Update latency display
                const avgLatency = this.getAverageLatency();
                if (avgLatency > 0) {
                    this.latencyDisplay.textContent = `${avgLatency.toFixed(1)}ms`;
                    
                    // Color code latency based on pet training effectiveness
                    if (avgLatency < 20) {
                        this.latencyDisplay.className = 'status-value status-good';
                    } else if (avgLatency < 50) {
                        this.latencyDisplay.className = 'status-value status-warning';
                    } else {
                        this.latencyDisplay.className = 'status-value status-error';
                    }
                }
            }

            updateVolumeDisplay() {
                const percentage = Math.round(this.volume * 100);
                this.volumeValue.textContent = `${percentage}%`;
            }

            announceToScreenReader(message) {
                if (this.srAnnouncer) {
                    this.srAnnouncer.textContent = message;
                }
            }

            // Cleanup when page unloads
            destroy() {
                // Save settings before destroying
                this.saveSettings();
                
                if (this.audioEngine) {
                    this.audioEngine.cleanup();
                }
                
                // Clear any timers
                if (this.pressTimer) {
                    clearTimeout(this.pressTimer);
                }
            }

            // Export/Import settings for backup
            exportSettings() {
                const settings = {
                    volume: this.volume,
                    selectedSound: this.selectedSound,
                    clickCount: this.clickCount,
                    exportDate: new Date().toISOString(),
                    version: '1.0.0'
                };
                
                const dataStr = JSON.stringify(settings, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'pet-clicker-settings.json';
                link.click();
                
                URL.revokeObjectURL(url);
            }

            async importSettings(file) {
                try {
                    const text = await file.text();
                    const settings = JSON.parse(text);
                    
                    if (settings.volume !== undefined) {
                        this.volume = Math.max(0, Math.min(1, settings.volume));
                        this.volumeSlider.value = this.volume;
                        this.audioEngine.setVolume(this.volume);
                        this.updateVolumeDisplay();
                    }
                    
                    if (settings.selectedSound && ['metal', 'plastic', 'box'].includes(settings.selectedSound)) {
                        this.selectedSound = settings.selectedSound;
                        this.soundSelector.value = this.selectedSound;
                        this.audioEngine.setSelectedSound(this.selectedSound);
                    }
                    
                    if (settings.clickCount !== undefined) {
                        this.clickCount = Math.max(0, settings.clickCount);
                        this.updateDisplay();
                    }
                    
                    this.saveSettings();
                    this.announceToScreenReader('Settings imported successfully');
                    
                } catch (error) {
                    console.error('Failed to import settings:', error);
                    this.announceToScreenReader('Failed to import settings');
                }
            }

            // Reset all data
            resetAllData() {
                if (confirm('Reset all data including click count and settings?')) {
                    this.clickCount = 0;
                    this.volume = 0.8;
                    this.selectedSound = 'metal';
                    
                    // Update UI
                    this.volumeSlider.value = this.volume;
                    this.soundSelector.value = this.selectedSound;
                    this.audioEngine.setVolume(this.volume);
                    this.audioEngine.setSelectedSound(this.selectedSound);
                    this.updateVolumeDisplay();
                    this.updateDisplay();
                    
                    // Clear stored data
                    try {
                        localStorage.removeItem('pet-clicker-settings');
                    } catch (error) {
                        console.log('Could not clear settings:', error);
                    }
                    
                    // Clear cache if requested
                    if (confirm('Also clear app cache? (This will require reloading the app)')) {
                        this.pwaManager.clearCache().then(() => {
                            window.location.reload();
                        });
                    }
                    
                    this.announceToScreenReader('All data reset');
                }
            }
        }

        // Initialize the application when DOM is loaded
        let petClicker = null;
        let mobileOptimizer = null;
        
        document.addEventListener('DOMContentLoaded', () => {
            petClicker = new PetClicker();
        });

        // Handle mobile-specific events
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                // Recalculate viewport after orientation change
                if (petClicker && petClicker.mobileOptimizer) {
                    petClicker.mobileOptimizer.handleOrientationChange();
                }
            }, 500);
        });

        // Handle page visibility changes (important for mobile battery saving)
        document.addEventListener('visibilitychange', () => {
            if (petClicker && petClicker.audioEngine) {
                if (document.hidden) {
                    // Pause audio context when app goes to background
                    if (petClicker.audioEngine.audioContext) {
                        petClicker.audioEngine.audioContext.suspend();
                    }
                } else {
                    // Resume when app comes back
                    if (petClicker.audioEngine.audioContext) {
                        petClicker.audioEngine.audioContext.resume();
                    }
                }
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (petClicker) {
                petClicker.destroy();
            }
        });

        // Prevent iOS zoom gestures
        document.addEventListener('gesturestart', (e) => {
            e.preventDefault();
        });

        // Handle iOS device motion (shake to reset counter - fun feature)
        if (window.DeviceMotionEvent) {
            let lastShake = 0;
            window.addEventListener('devicemotion', (event) => {
                const acceleration = event.accelerationIncludingGravity;
                const now = Date.now();
                
                if (acceleration && now - lastShake > 1000) {
                    const totalAcceleration = Math.abs(acceleration.x) + 
                                            Math.abs(acceleration.y) + 
                                            Math.abs(acceleration.z);
                    
                    if (totalAcceleration > 25 && petClicker) {
                        // Shake detected - could reset counter or provide feedback
                        if (petClicker.mobileOptimizer.hapticSupported) {
                            petClicker.mobileOptimizer.triggerHaptic('success');
                        }
                        lastShake = now;
                    }
                }
            });
        }

        // Wake lock to prevent screen from sleeping during training
        let wakeLock = null;
        let wakeLockSupported = false;

        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLockSupported = true;
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Screen wake lock active');
                    
                    // Handle wake lock release (e.g., when tab becomes hidden)
                    wakeLock.addEventListener('release', () => {
                        console.log('Screen wake lock released');
                    });
                }
            } catch (err) {
                // Silently handle wake lock errors - they're not critical for functionality
                console.log('Wake lock not available or denied - screen may sleep during training');
                wakeLockSupported = false;
            }
        }

        // Re-acquire wake lock when page becomes visible again
        document.addEventListener('visibilitychange', async () => {
            if (wakeLockSupported && wakeLock !== null && document.visibilityState === 'visible') {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                } catch (err) {
                    // Silently handle - wake lock is optional
                }
            }
        });

        // Request wake lock on first click (not just any interaction)
        let wakeLockRequested = false;
        function tryRequestWakeLock() {
            if (!wakeLockRequested) {
                wakeLockRequested = true;
                requestWakeLock();
            }
        }

        // Only request wake lock when actually clicking the clicker button
        document.addEventListener('DOMContentLoaded', () => {
            const clickButton = document.getElementById('click-button');
            if (clickButton) {
                clickButton.addEventListener('click', tryRequestWakeLock, { once: true });
                clickButton.addEventListener('touchstart', tryRequestWakeLock, { once: true });
            }
        });
    </script>
</body>
</html>
