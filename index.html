<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#2196F3">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Pet Clicker">
    <meta name="description" content="Professional pet training clicker with ultra-low latency audio for dogs and cats">

    <!-- PWA Manifest -->
    <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIlBldCBUcmFpbmluZyBDbGlja2VyIiwKICAic2hvcnRfbmFtZSI6ICJQZXRDbGlja2VyIiwKICAiZGVzY3JpcHRpb24iOiAiUHJvZmVzc2lvbmFsIHBldCB0cmFpbmluZyBjbGlja2VyIHdpdGggdWx0cmEtbG93IGxhdGVuY3kgYXVkaW8iLAogICJzdGFydF91cmwiOiAiLyIsCiAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgIm9yaWVudGF0aW9uIjogInBvcnRyYWl0IiwKICAidGhlbWVfY29sb3IiOiAiIzIxOTZGMyIsCiAgImJhY2tncm91bmRfY29sb3IiOiAiI2ZmZmZmZiIsCiAgImNhdGVnb3JpZXMiOiBbInBldHMiLCAidHJhaW5pbmciLCAidG9vbHMiXSwKICAibGFuZyI6ICJlbiIsCiAgImljb25zIjogWwogICAgewogICAgICAic3JjIjogImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UazJJaUJvWldsbmFIUTlJakU1TmlJZ2RtbGxkMEp2ZUQwaU1DQXdJREU1TmlBeE9UWWlJR1pwYkd3OUlpTXlNVGsyUmpNaVBnb2dJRHhqYVhKamJHVWdZM2c5SWprNElpQmplVDBpT1RnaUlISTlJekl3SWlCbWFXeHNQU0lqWm1abUlpOCtDaUFnUEdOcGNtTnNaU0JqZUQwaU9UZ2lJR041UFNJNFppSWdjajBpTVRVaUlHWnBiR3c5SWlNeU1UazJSak1pTHo0S1BDOXpkbWMrIiwKICAgICAgInNpemVzIjogIjE5MngxOTIiLAogICAgICAidHlwZSI6ICJpbWFnZS9zdmcreG1sIiwKICAgICAgInB1cnBvc2UiOiAiYW55IG1hc2thYmxlIgogICAgfSwKICAgIHsKICAgICAgInNyYyI6ICJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlOVEV5SWlCb1pXbG5hSFE5SWpVeE1pSWdkbWxsZDBKdmVEMGlNQ0F3SURRNE1DQTBPREFpSUdacGJHczlJaU15TVRrMlJqTWlQZ29nSUR4amFYSmpiR1VnWTNnOUlqSTBNQ0lnWTNrOUlqSTBNQ0lnY2owaU1UQXdJaUJtYVd4c1BTSWpabVptSWk4K0NpQWdQR05wY21Oc1pTQmplRDBpTWpRd0lpQmplVDBpTVRrd0lpQnlQU0kzTUNJZ1ptbHNiRDBpSXpJeE9UWkdNeUl2UGdvOEwzTjJaejQiLAogICAgICAic2l6ZXMiOiAiNTEyeDUxMiIsCiAgICAgICJ0eXBlIjogImltYWdlL3N2Zyt4bWwiLAogICAgICAicHVycG9zZSI6ICJhbnkgbWFza2FibGUiCiAgICB9CiAgXSwKICAic2hvcnRjdXRzIjogWwogICAgewogICAgICAibmFtZSI6ICJRdWljayBDbGljayIsCiAgICAgICJ1cmwiOiAiLz9xdWljaz10cnVlIiwKICAgICAgImRlc2NyaXB0aW9uIjogIk9wZW4gY2xpY2tlciByZWFkeSB0byB1c2UiCiAgICB9CiAgXQp9">

    <!-- iOS Icons -->
    <link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTk2IiBoZWlnaHQ9IjE5NiIgdmlld0JveD0iMCAwIDE5NiAxOTYiIGZpbGw9IiMyMTk2RjMiPgogIDxjaXJjbGUgY3g9Ijk4IiBjeT0iOTgiIHI9IjIwIiBmaWxsPSIjZmZmIi8+CiAgPGNpcmNsZSBjeD0iOTgiIGN5PSI4ZiIgcj0iMTUiIGZpbGw9IiMyMTk2RjMiLz4KPC9zdmc+">

    <title>Pet Training Clicker</title>

    <style>
        /* CSS Variables - Design System */
        :root {
            /* Primary Colors */
            --primary-blue: #2196F3;
            --primary-blue-dark: #1976D2;
            --primary-blue-light: #E3F2FD;

            /* Neutral Colors */
            --white: #FFFFFF;
            --gray-50: #FAFAFA;
            --gray-100: #F5F5F5;
            --gray-200: #EEEEEE;
            --gray-400: #BDBDBD;
            --gray-600: #757575;
            --gray-900: #212121;

            /* Feedback Colors */
            --success-green: #4CAF50;
            --warning-orange: #FF9800;
            --error-red: #F44336;

            /* Typography */
            --font-primary: -apple-system, BlinkMacSystemFont, 'Segoe UI',
            Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            --text-xs: 12px;
            --text-sm: 14px;
            --text-base: 16px;
            --text-lg: 18px;
            --text-xl: 24px;
            --text-2xl: 32px;
        }

        /* Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-primary);
            background: var(--gray-50);
            color: var(--gray-900);
            line-height: 1.5;
            overflow-x: hidden;
            -webkit-tap-highlight-color: transparent;
        }

        /* Main Container */
        .container {
            width: 100%;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 20px;
            position: relative;
        }

        /* App Header */
        .app-header {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        .app-title {
            font-size: var(--text-lg);
            font-weight: 600;
            color: var(--gray-600);
            margin-bottom: 4px;
        }

        .app-subtitle {
            font-size: var(--text-sm);
            color: var(--gray-400);
        }

        /* Enhanced Touch Targets */
        .click-button {
            width: min(300px, 80vw);
            height: min(300px, 80vw);
            max-height: 50vh;

            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--primary-blue-dark) 100%);
            border: none;
            border-radius: 50%;

            color: var(--white);
            font-size: var(--text-xl);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;

            cursor: pointer;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;

            box-shadow:
                    0 8px 16px rgba(33, 150, 243, 0.3),
                    0 2px 4px rgba(0, 0, 0, 0.1);

            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;

            /* Enhanced for mobile touch */
            min-height: 44px; /* iOS accessibility minimum */
            min-width: 44px;
        }

        /* Enhanced Active State for Mobile */
        .click-button:active,
        .click-button.clicking {
            transform: scale(0.95);
            box-shadow:
                    0 4px 8px rgba(33, 150, 243, 0.4),
                    0 1px 2px rgba(0, 0, 0, 0.2);
        }

        /* iOS Specific Optimizations */
        @supports (-webkit-touch-callout: none) {
            .click-button {
                -webkit-appearance: none;
                -webkit-user-select: none;
                -webkit-touch-callout: none;
                -webkit-tap-highlight-color: rgba(0,0,0,0);
            }

            /* Prevent iOS zoom on focus */
            input, select, textarea {
                font-size: 16px;
            }
        }

        /* Android Specific Optimizations */
        @media screen and (-webkit-min-device-pixel-ratio: 0) {
            .click-button {
                /* Improve touch response on Android */
                will-change: transform;
            }
        }

        /* Enhanced Control Buttons for Mobile */
        .control-button {
            width: 56px;
            height: 56px;
            border-radius: 12px;
            border: 1px solid var(--gray-200);
            background: var(--white);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            font-size: var(--text-sm);
            font-weight: 500;

            /* Mobile touch optimizations */
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 44px;
            min-width: 44px;
        }

        .control-button:hover {
            border-color: var(--primary-blue);
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2);
        }

        .control-button.active {
            background: var(--primary-blue);
            border-color: var(--primary-blue);
            color: var(--white);
        }

        /* Mobile Landscape Optimizations */
        @media (orientation: landscape) and (max-height: 500px) {
            .container {
                padding: 10px;
            }

            .app-header {
                position: static;
                margin-bottom: 10px;
            }

            .app-title {
                font-size: var(--text-base);
            }

            .app-subtitle {
                display: none; /* Hide subtitle in tight landscape */
            }

            .click-button {
                width: min(200px, 40vw);
                height: min(200px, 60vh);
                font-size: var(--text-lg);
            }

            .control-panel {
                margin-top: 20px;
                gap: 12px;
            }

            .status-panel {
                font-size: 10px;
                gap: 15px;
            }
        }

        /* Haptic Feedback Enhancement Indicator */
        .haptic-pulse {
            animation: haptic-pulse 0.1s ease-out;
        }

        @keyframes haptic-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        /* Loading State for Mobile */
        .mobile-loading {
            pointer-events: none;
            opacity: 0.7;
        }

        .mobile-loading .click-button {
            background: var(--gray-400);
        }

        /* Offline Mode Styles */
        .offline .click-button {
            background: linear-gradient(135deg, var(--gray-400) 0%, var(--gray-600) 100%);
        }

        .offline .app-header::after {
            content: ' (Offline)';
            color: var(--warning-orange);
            font-size: var(--text-sm);
        }

        /* PWA Installed Styles */
        .pwa-installed .app-header {
            padding-top: env(safe-area-inset-top, 0);
        }

        /* Settings Panel Styles */
        .settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .settings-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .settings-panel {
            background: var(--white);
            border-radius: 16px;
            padding: 24px;
            width: min(400px, 90vw);
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
            transform: translateY(20px);
            transition: transform 0.3s ease;
        }

        .settings-overlay.active .settings-panel {
            transform: translateY(0);
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--gray-200);
        }

        .settings-title {
            font-size: var(--text-xl);
            font-weight: 600;
            color: var(--gray-900);
        }

        .close-button {
            background: none;
            border: none;
            font-size: 24px;
            color: var(--gray-400);
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .close-button:hover {
            background: var(--gray-100);
            color: var(--gray-600);
        }

        .settings-section {
            margin-bottom: 24px;
        }

        .settings-section:last-child {
            margin-bottom: 0;
        }

        .section-title {
            font-size: var(--text-lg);
            font-weight: 600;
            color: var(--gray-900);
            margin-bottom: 12px;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid var(--gray-100);
        }

        .setting-item:last-child {
            border-bottom: none;
        }

        .setting-label {
            flex: 1;
            margin-right: 16px;
        }

        .setting-name {
            font-weight: 500;
            color: var(--gray-900);
            margin-bottom: 2px;
        }

        .setting-description {
            font-size: var(--text-sm);
            color: var(--gray-600);
        }

        .setting-control {
            flex-shrink: 0;
        }

        .toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
            background: var(--gray-300);
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .toggle-switch.active {
            background: var(--primary-blue);
        }

        .toggle-switch::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: var(--white);
            border-radius: 50%;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .toggle-switch.active::before {
            transform: translateX(20px);
        }

        .action-button {
            background: var(--primary-blue);
            color: var(--white);
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: var(--text-sm);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .action-button:hover {
            background: var(--primary-blue-dark);
        }

        .action-button.secondary {
            background: var(--gray-100);
            color: var(--gray-700);
        }

        .action-button.secondary:hover {
            background: var(--gray-200);
        }

        .action-button.danger {
            background: var(--error-red);
        }

        .action-button.danger:hover {
            background: #D32F2F;
        }

        .info-value {
            font-size: var(--text-lg);
            font-weight: 600;
            color: var(--primary-blue);
        }

        /* Ripple Effect */
        .click-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .click-button.clicking::before {
            animation: ripple 0.6s linear;
        }

        /* Control Panel */
        .control-panel {
            display: flex;
            gap: 16px;
            justify-content: center;
            margin-top: 40px;
            flex-wrap: wrap;
        }

        /* Settings button positioning */
        .settings-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }

        .control-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            min-width: 80px;
        }

        .control-label {
            font-size: var(--text-sm);
            color: var(--gray-600);
            font-weight: 500;
        }

        /* Status Display */
        .status-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            font-size: var(--text-xs);
            color: var(--gray-600);
            text-align: center;
        }

        .status-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .status-value {
            font-weight: 600;
            color: var(--gray-900);
        }

        .status-good { color: var(--success-green); }
        .status-warning { color: var(--warning-orange); }
        .status-error { color: var(--error-red); }

        /* Screen Reader Only */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Animations */
        @keyframes click-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes ripple {
            0% {
                width: 0;
                height: 0;
                opacity: 1;
            }
            100% {
                width: 400px;
                height: 400px;
                opacity: 0;
            }
        }

        /* Responsive Design */
        @media (min-width: 481px) and (orientation: landscape) {
            .container {
                flex-direction: row;
                gap: 40px;
                padding: 30px;
            }

            .main-content {
                display: flex;
                flex-direction: column;
                align-items: center;
                padding-top: 60px;
            }

            .control-panel {
                flex-direction: column;
                margin-top: 0;
                margin-left: 0;
            }

            .app-header {
                position: static;
                transform: none;
                margin-bottom: 20px;
            }
        }

        @media (min-width: 769px) {
            .container {
                max-width: 600px;
                margin: 0 auto;
                flex-direction: column;
                padding: 40px;
            }

            .click-button {
                width: 320px;
                height: 320px;
                max-height: none;
            }

            .control-panel {
                flex-direction: row;
                gap: 24px;
                margin-top: 50px;
            }

            .status-panel {
                position: static;
                transform: none;
                margin-top: 30px;
                padding: 16px;
                background: var(--white);
                border-radius: 8px;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            }
        }

        /* Loading State */
        .loading {
            opacity: 0.7;
            pointer-events: none;
        }

        .loading-spinner {
            width: 24px;
            height: 24px;
            border: 2px solid var(--gray-200);
            border-top: 2px solid var(--primary-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>

</head>
<body>
<div class="container">

    <!-- Main Content -->
    <main class="main-content">
        <!-- Primary Click Button -->
        <button
                id="click-button"
                class="click-button"
                aria-label="Pet training clicker - Press to make click sound"
                role="button"
        >
            CLICK
        </button>

    </main>

    <!-- Settings Button at Bottom -->
    <div class="settings-container">
        <button
                id="settings-button"
                class="control-button"
                aria-label="Open settings"
                style="font-size: 24px; width: 60px; height: 60px;"
        >
            ⚙️
        </button>
    </div>

</div>

<!-- Settings Panel -->
<div id="settings-overlay" class="settings-overlay">
    <div class="settings-panel">
        <div class="settings-header">
            <h2 class="settings-title">Settings</h2>
            <button id="close-settings" class="close-button" aria-label="Close settings">×</button>
        </div>

        <!-- Audio Settings -->
        <div class="settings-section">
            <h3 class="section-title">Audio Settings</h3>

            <div class="setting-item">
                <div class="setting-label">
                    <div class="setting-name">Clicker Type</div>
                    <div class="setting-description">Sound characteristics</div>
                </div>
                <div class="setting-control">
                    <select id="settings-sound" style="padding: 4px 8px; border-radius: 4px;">
                        <option value="snap">Snap (Natural)</option>
                        <option value="metal">Metal (Sharp)</option>
                        <option value="plastic">Plastic (Soft)</option>
                        <option value="box">Box (Loud)</option>
                    </select>
                </div>
            </div>

            <div class="setting-item">
                <div class="setting-label">
                    <div class="setting-name">Audio Engine</div>
                    <div class="setting-description">Current audio system</div>
                </div>
                <div class="setting-control">
                    <span id="audio-engine-info" class="info-value">Web Audio API</span>
                </div>
            </div>
        </div>

        <!-- Accessibility Settings -->
        <div class="settings-section">
            <h3 class="section-title">Accessibility</h3>

            <div class="setting-item">
                <div class="setting-label">
                    <div class="setting-name">Haptic Feedback</div>
                    <div class="setting-description">Vibration on button press</div>
                </div>
                <div class="setting-control">
                    <div id="haptic-toggle" class="toggle-switch active"></div>
                </div>
            </div>

            <div class="setting-item">
                <div class="setting-label">
                    <div class="setting-name">Screen Reader</div>
                    <div class="setting-description">Voice announcements</div>
                </div>
                <div class="setting-control">
                    <div id="screenreader-toggle" class="toggle-switch active"></div>
                </div>
            </div>

        </div>

        <!-- Data Management -->
        <div class="settings-section">
            <h3 class="section-title">Data Management</h3>

            <div class="setting-item">
                <div class="setting-label">
                    <div class="setting-name">Export Settings</div>
                    <div class="setting-description">Download backup file</div>
                </div>
                <div class="setting-control">
                    <button id="export-settings" class="action-button">Export</button>
                </div>
            </div>

            <div class="setting-item">
                <div class="setting-label">
                    <div class="setting-name">Import Settings</div>
                    <div class="setting-description">Restore from backup</div>
                </div>
                <div class="setting-control">
                    <input type="file" id="import-file" accept=".json" style="display: none;">
                    <button id="import-settings" class="action-button secondary">Import</button>
                </div>
            </div>

            <div class="setting-item">
                <div class="setting-label">
                    <div class="setting-name">Reset All Data</div>
                    <div class="setting-description">Clear all settings</div>
                </div>
                <div class="setting-control">
                    <button id="reset-all" class="action-button danger">Reset All</button>
                </div>
            </div>
        </div>

        <!-- App Information -->
        <div class="settings-section">
            <h3 class="section-title">App Information</h3>

            <div class="setting-item">
                <div class="setting-label">
                    <div class="setting-name">Version</div>
                    <div class="setting-description">App version</div>
                </div>
                <div class="setting-control">
                    <span class="info-value">2.0.0</span>
                </div>
            </div>

            <div class="setting-item">
                <div class="setting-label">
                    <div class="setting-name">Installation</div>
                    <div class="setting-description">App install status</div>
                </div>
                <div class="setting-control">
                    <span id="install-status" class="info-value">Browser</span>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Screen Reader Announcements -->
<div id="sr-announcer" class="sr-only" aria-live="polite" aria-atomic="true"></div>

<script>
    // PWA Service Worker Registration and Management
    class PWAManager {
        constructor() {
            this.isOnline = navigator.onLine;
            this.deferredPrompt = null;
            this.isInstalled = false;
            this.updateAvailable = false;

            this.init();
        }

        async init() {
            await this.registerServiceWorker();
            this.setupInstallPrompt();
            this.setupOnlineDetection();
            this.checkInstallStatus();
        }

        async registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                try {
                    const swCode = this.generateServiceWorkerCode();
                    const blob = new Blob([swCode], { type: 'application/javascript' });
                    const swUrl = URL.createObjectURL(blob);

                    const registration = await navigator.serviceWorker.register(swUrl);
                    console.log('Service Worker registered successfully');
                    return registration;
                } catch (error) {
                    console.log('Service Worker registration failed:', error);
                }
            }
        }

        generateServiceWorkerCode() {
            return `
                const CACHE_NAME = 'pet-clicker-v2.0.0';

                self.addEventListener('install', (event) => {
                    event.waitUntil(
                        caches.open(CACHE_NAME).then((cache) => {
                            return cache.add(new Request(self.location.href));
                        })
                    );
                    self.skipWaiting();
                });

                self.addEventListener('activate', (event) => {
                    event.waitUntil(
                        caches.keys().then((cacheNames) => {
                            return Promise.all(
                                cacheNames.map((cacheName) => {
                                    if (cacheName !== CACHE_NAME) {
                                        return caches.delete(cacheName);
                                    }
                                })
                            );
                        })
                    );
                    self.clients.claim();
                });

                self.addEventListener('fetch', (event) => {
                    if (event.request.method !== 'GET') return;

                    event.respondWith(
                        caches.match(event.request).then((response) => {
                            return response || fetch(event.request).then((response) => {
                                if (!response || response.status !== 200) {
                                    return response;
                                }

                                const responseToCache = response.clone();
                                caches.open(CACHE_NAME).then((cache) => {
                                    cache.put(event.request, responseToCache);
                                });

                                return response;
                            });
                        }).catch(() => {
                            if (event.request.mode === 'navigate') {
                                return new Response(
                                    '<h1>Offline</h1><p>Pet Clicker is cached and ready to use offline!</p>',
                                    { headers: { 'Content-Type': 'text/html' } }
                                );
                            }
                        })
                    );
                });
            `;
        }

        setupInstallPrompt() {
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                this.deferredPrompt = e;
                this.showInstallButton();
            });

            window.addEventListener('appinstalled', () => {
                this.isInstalled = true;
                this.hideInstallButton();
            });
        }

        setupOnlineDetection() {
            window.addEventListener('online', () => {
                this.isOnline = true;
                this.updateOnlineStatus();
            });

            window.addEventListener('offline', () => {
                this.isOnline = false;
                this.updateOnlineStatus();
            });

            this.updateOnlineStatus();
        }

        checkInstallStatus() {
            const isStandalone = window.matchMedia('(display-mode: standalone)').matches ||
                window.navigator.standalone ||
                document.referrer.includes('android-app://');

            if (isStandalone) {
                this.isInstalled = true;
                document.body.classList.add('pwa-installed');
            }
        }

        showInstallButton() {
            const installButton = this.createInstallButton();
            if (installButton && !document.querySelector('.install-button')) {
                const controlPanel = document.querySelector('.control-panel');
                if (controlPanel) {
                    controlPanel.appendChild(installButton);
                }
            }
        }

        createInstallButton() {
            const installItem = document.createElement('div');
            installItem.className = 'control-item';

            const label = document.createElement('span');
            label.className = 'control-label';
            label.textContent = 'Install';

            const button = document.createElement('button');
            button.className = 'control-button install-button';
            button.setAttribute('aria-label', 'Install app');
            button.innerHTML = '📱';

            button.addEventListener('click', async () => {
                const installed = await this.promptInstall();
                if (installed) {
                    installItem.remove();
                }
            });

            installItem.appendChild(label);
            installItem.appendChild(button);

            return installItem;
        }

        hideInstallButton() {
            const installButton = document.querySelector('.install-button');
            if (installButton) {
                installButton.closest('.control-item')?.remove();
            }
        }

        async promptInstall() {
            if (!this.deferredPrompt) return false;

            this.deferredPrompt.prompt();
            const result = await this.deferredPrompt.userChoice;

            if (result.outcome === 'accepted') {
                this.isInstalled = true;
            }

            this.deferredPrompt = null;
            return result.outcome === 'accepted';
        }

        updateOnlineStatus() {
            document.body.classList.toggle('offline', !this.isOnline);
        }
    }

    // Mobile Optimization
    class MobileOptimizer {
        constructor() {
            this.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            this.isAndroid = /Android/.test(navigator.userAgent);
            this.hapticSupported = 'vibrate' in navigator;

            this.init();
        }

        init() {
            this.setupViewport();
            this.setupTouchOptimizations();
            this.setupHapticFeedback();
            this.setupIOSSpecific();
        }

        setupViewport() {
            let viewport = document.querySelector('meta[name="viewport"]');
            if (viewport) {
                viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover';
            }

            document.addEventListener('gesturestart', (e) => e.preventDefault());
            document.addEventListener('gesturechange', (e) => e.preventDefault());
            document.addEventListener('gestureend', (e) => e.preventDefault());
        }

        setupTouchOptimizations() {
            let lastTouchEnd = 0;
            document.addEventListener('touchend', (e) => {
                const now = Date.now();
                if (now - lastTouchEnd <= 300) {
                    e.preventDefault();
                }
                lastTouchEnd = now;
            }, false);
        }

        setupHapticFeedback() {
            this.hapticPatterns = {
                click: [20],
                clack: [10],
                error: [50, 50, 50]
            };
        }

        setupIOSSpecific() {
            if (!this.isIOS) return;

            document.body.style.overscrollBehavior = 'none';
            document.body.style.webkitUserSelect = 'none';
            document.body.style.webkitTouchCallout = 'none';
        }

        triggerHaptic(pattern = 'click') {
            if (!this.hapticSupported) return;

            const hapticPattern = this.hapticPatterns[pattern] || this.hapticPatterns.click;

            try {
                navigator.vibrate(hapticPattern);
            } catch (error) {
                console.log('Haptic feedback not available');
            }
        }

        isValidTouch(touch, element) {
            const rect = element.getBoundingClientRect();
            return (
                touch.clientX >= rect.left &&
                touch.clientX <= rect.right &&
                touch.clientY >= rect.top &&
                touch.clientY <= rect.bottom
            );
        }
    }

    // Audio Engine
    class AudioEngine {
        constructor() {
            this.audioContext = null;
            this.audioBuffers = new Map();
            this.isInitialized = false;
            this.audioPool = [];
            this.poolSize = 8;
            this.currentPoolIndex = 0;
            this.selectedSound = 'snap';
            this.useHTML5Fallback = false;

            this.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            this.isAndroid = /Android/.test(navigator.userAgent);
        }

        async initialize() {
            try {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    latencyHint: 'interactive',
                    sampleRate: 44100
                });

                console.log(`AudioContext created - Base latency: ${(this.audioContext.baseLatency * 1000).toFixed(1)}ms`);

                await this.loadAllSounds();
                this.initializeAudioPool();
                await this.setupMobileWorkarounds();

                this.isInitialized = true;
                return true;

            } catch (error) {
                console.warn('Web Audio API failed, falling back to HTML5 Audio:', error);
                this.initializeHTML5Fallback();
                return false;
            }
        }

        async loadAllSounds() {
            const sounds = {
                'metal-click': this.generateMetalClick(),
                'metal-clack': this.generateMetalClack(),
                'plastic-click': this.generatePlasticClick(),
                'plastic-clack': this.generatePlasticClack(),
                'box-click': this.generateBoxClick(),
                'box-clack': this.generateBoxClack(),
                'snap-click': this.generateFingerSnapClick(),
                'snap-clack': this.generateFingerSnapClack()
            };

            for (const [name, audioBuffer] of Object.entries(sounds)) {
                this.audioBuffers.set(name, audioBuffer);
            }
        }

        generateMetalClick() {
            const sampleRate = this.audioContext.sampleRate;
            const duration = 0.08;
            const length = sampleRate * duration;
            const buffer = this.audioContext.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < length; i++) {
                const t = i / sampleRate;
                const envelope = Math.exp(-t * 25);
                const noise = (Math.random() - 0.5) * 0.3;
                const tone1 = Math.sin(2 * Math.PI * 3000 * t) * 0.4;
                const tone2 = Math.sin(2 * Math.PI * 4500 * t) * 0.3;
                const tone3 = Math.sin(2 * Math.PI * 6000 * t) * 0.2;

                data[i] = (tone1 + tone2 + tone3 + noise) * envelope;
            }
            return buffer;
        }

        generateMetalClack() {
            const sampleRate = this.audioContext.sampleRate;
            const duration = 0.06;
            const length = sampleRate * duration;
            const buffer = this.audioContext.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < length; i++) {
                const t = i / sampleRate;
                const envelope = Math.exp(-t * 30);
                const noise = (Math.random() - 0.5) * 0.2;
                const tone1 = Math.sin(2 * Math.PI * 2200 * t) * 0.3;
                const tone2 = Math.sin(2 * Math.PI * 3200 * t) * 0.2;
                const tone3 = Math.sin(2 * Math.PI * 4800 * t) * 0.15;

                data[i] = (tone1 + tone2 + tone3 + noise) * envelope * 0.7;
            }
            return buffer;
        }

        generatePlasticClick() {
            const sampleRate = this.audioContext.sampleRate;
            const duration = 0.1;
            const length = sampleRate * duration;
            const buffer = this.audioContext.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < length; i++) {
                const t = i / sampleRate;
                const envelope = Math.exp(-t * 15);
                const noise = (Math.random() - 0.5) * 0.2;
                const tone1 = Math.sin(2 * Math.PI * 2000 * t) * 0.5;
                const tone2 = Math.sin(2 * Math.PI * 3000 * t) * 0.3;

                data[i] = (tone1 + tone2 + noise) * envelope * 0.8;
            }
            return buffer;
        }

        generatePlasticClack() {
            const sampleRate = this.audioContext.sampleRate;
            const duration = 0.08;
            const length = sampleRate * duration;
            const buffer = this.audioContext.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < length; i++) {
                const t = i / sampleRate;
                const envelope = Math.exp(-t * 18);
                const noise = (Math.random() - 0.5) * 0.15;
                const tone1 = Math.sin(2 * Math.PI * 1600 * t) * 0.4;
                const tone2 = Math.sin(2 * Math.PI * 2400 * t) * 0.25;

                data[i] = (tone1 + tone2 + noise) * envelope * 0.6;
            }
            return buffer;
        }

        generateBoxClick() {
            const sampleRate = this.audioContext.sampleRate;
            const duration = 0.11;
            const length = sampleRate * duration;
            const buffer = this.audioContext.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < length; i++) {
                const t = i / sampleRate;
                const envelope = Math.exp(-t * 20);
                const noise = (Math.random() - 0.5) * 0.4;
                const tone1 = Math.sin(2 * Math.PI * 2500 * t) * 0.4;
                const tone2 = Math.sin(2 * Math.PI * 4000 * t) * 0.3;
                const tone3 = Math.sin(2 * Math.PI * 6000 * t) * 0.2;
                const tone4 = Math.sin(2 * Math.PI * 8000 * t) * 0.1;

                data[i] = (tone1 + tone2 + tone3 + tone4 + noise) * envelope;
            }
            return buffer;
        }

        generateBoxClack() {
            const sampleRate = this.audioContext.sampleRate;
            const duration = 0.09;
            const length = sampleRate * duration;
            const buffer = this.audioContext.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < length; i++) {
                const t = i / sampleRate;
                const envelope = Math.exp(-t * 22);
                const noise = (Math.random() - 0.5) * 0.3;
                const tone1 = Math.sin(2 * Math.PI * 2000 * t) * 0.35;
                const tone2 = Math.sin(2 * Math.PI * 3200 * t) * 0.25;
                const tone3 = Math.sin(2 * Math.PI * 4800 * t) * 0.15;
                const tone4 = Math.sin(2 * Math.PI * 6400 * t) * 0.08;

                data[i] = (tone1 + tone2 + tone3 + tone4 + noise) * envelope * 0.75;
            }
            return buffer;
        }

        generateFingerSnapClick() {
            const sampleRate = this.audioContext.sampleRate;
            const duration = 0.12;
            const length = sampleRate * duration;
            const buffer = this.audioContext.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);

            const attack = 0.001;
            const decay = 0.07;
            const bodyHz = 2000;
            const airHz = 7000;
            const tailGain = 0.6;
            const impulseGain = 0.9;

            for (let i = 0; i < length; i++) {
                const t = i / sampleRate;

                const noise = (Math.random() * 2 - 1);

                const bodyEnv = Math.exp(-t * (1 / decay * 10));
                const bodyTone = Math.sin(2 * Math.PI * bodyHz * t) * bodyEnv;
                const bodyFiltered = noise * 0.3 + bodyTone * 0.7;

                const airEnv = Math.exp(-t * (1 / decay * 15));
                const airTone = Math.sin(2 * Math.PI * airHz * t) * airEnv;
                const airFiltered = noise * 0.5 + airTone * 0.5;

                let tailEnvelope;
                if (t < attack) {
                    tailEnvelope = (t / attack) * tailGain;
                } else {
                    tailEnvelope = tailGain * Math.exp(-(t - attack) / decay * 8);
                }

                const impulseDur = 0.006;
                let impulse = 0;
                if (t < impulseDur) {
                    const impulseFreq = 2200 - (t / impulseDur) * 400;
                    const impulseEnv = impulseGain * Math.exp(-t / impulseDur * 8);
                    impulse = Math.sin(2 * Math.PI * impulseFreq * t) * impulseEnv;
                }

                const bodyComponent = bodyFiltered * tailEnvelope * 0.4;
                const airComponent = airFiltered * tailEnvelope * 0.3;

                data[i] = bodyComponent + airComponent + impulse;
            }

            return buffer;
        }

        generateFingerSnapClack() {
            const sampleRate = this.audioContext.sampleRate;
            const duration = 0.08;
            const length = sampleRate * duration;
            const buffer = this.audioContext.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);

            const attack = 0.001;
            const decay = 0.05;
            const bodyHz = 1600;
            const airHz = 5500;
            const tailGain = 0.4;
            const impulseGain = 0.5;

            for (let i = 0; i < length; i++) {
                const t = i / sampleRate;

                const noise = (Math.random() * 2 - 1);

                const bodyEnv = Math.exp(-t * (1 / decay * 12));
                const bodyTone = Math.sin(2 * Math.PI * bodyHz * t) * bodyEnv;
                const bodyFiltered = noise * 0.2 + bodyTone * 0.6;

                const airEnv = Math.exp(-t * (1 / decay * 18));
                const airTone = Math.sin(2 * Math.PI * airHz * t) * airEnv;
                const airFiltered = noise * 0.3 + airTone * 0.4;

                let tailEnvelope;
                if (t < attack) {
                    tailEnvelope = (t / attack) * tailGain;
                } else {
                    tailEnvelope = tailGain * Math.exp(-(t - attack) / decay * 10);
                }

                const impulseDur = 0.004;
                let impulse = 0;
                if (t < impulseDur) {
                    const impulseFreq = 1800 - (t / impulseDur) * 200;
                    const impulseEnv = impulseGain * Math.exp(-t / impulseDur * 10);
                    impulse = Math.sin(2 * Math.PI * impulseFreq * t) * impulseEnv;
                }

                const bodyComponent = bodyFiltered * tailEnvelope * 0.3;
                const airComponent = airFiltered * tailEnvelope * 0.2;

                data[i] = (bodyComponent + airComponent + impulse) * 0.7;
            }

            return buffer;
        }

        initializeAudioPool() {
            this.audioPool = [];
            for (let i = 0; i < this.poolSize; i++) {
                const gainNode = this.audioContext.createGain();
                gainNode.connect(this.audioContext.destination);
                this.audioPool.push({
                    gainNode: gainNode,
                    isPlaying: false
                });
            }
        }

        async setupMobileWorkarounds() {
            if (this.isIOS) {
                await this.setupIOSWorkarounds();
            }

            this.setupUserGestureHandler();
        }

        async setupIOSWorkarounds() {
            try {
                const silentBuffer = this.audioContext.createBuffer(1, 1, this.audioContext.sampleRate);
                const source = this.audioContext.createBufferSource();
                source.buffer = silentBuffer;
                source.connect(this.audioContext.destination);
                source.start();

                console.log('iOS silent mode workaround applied');
            } catch (error) {
                console.warn('iOS workaround failed:', error);
            }
        }

        setupUserGestureHandler() {
            const unlockAudio = async () => {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                    console.log('AudioContext resumed');
                }

                document.removeEventListener('touchstart', unlockAudio);
                document.removeEventListener('click', unlockAudio);
            };

            document.addEventListener('touchstart', unlockAudio);
            document.addEventListener('click', unlockAudio);
        }

        playClick() {
            if (this.useHTML5Fallback) {
                return this.playClickHTML5();
            }

            if (!this.isInitialized || !this.audioContext) {
                console.warn('Audio not initialized');
                return false;
            }

            if (this.audioContext.state === 'suspended') {
                this.audioContext.resume();
            }

            const audioSource = this.getNextAudioSource();
            if (!audioSource) {
                console.warn('All audio sources busy');
                return false;
            }

            const buffer = this.audioBuffers.get(`${this.selectedSound}-click`);
            if (!buffer) {
                console.warn('Audio buffer not found:', `${this.selectedSound}-click`);
                return false;
            }

            const bufferSource = this.audioContext.createBufferSource();
            bufferSource.buffer = buffer;

            audioSource.gainNode.gain.setValueAtTime(1, this.audioContext.currentTime);

            bufferSource.connect(audioSource.gainNode);
            bufferSource.start(0);

            audioSource.isPlaying = true;
            bufferSource.onended = () => {
                audioSource.isPlaying = false;
            };

            return true;
        }

        playClack() {
            if (this.useHTML5Fallback) {
                return this.playClackHTML5();
            }

            if (!this.isInitialized || !this.audioContext) {
                console.warn('Audio not initialized');
                return false;
            }

            if (this.audioContext.state === 'suspended') {
                this.audioContext.resume();
            }

            const audioSource = this.getNextAudioSource();
            if (!audioSource) {
                console.warn('All audio sources busy');
                return false;
            }

            const buffer = this.audioBuffers.get(`${this.selectedSound}-clack`);
            if (!buffer) {
                console.warn('Audio buffer not found:', `${this.selectedSound}-clack`);
                return false;
            }

            const bufferSource = this.audioContext.createBufferSource();
            bufferSource.buffer = buffer;

            audioSource.gainNode.gain.setValueAtTime(0.85, this.audioContext.currentTime);

            bufferSource.connect(audioSource.gainNode);
            bufferSource.start(0);

            audioSource.isPlaying = true;
            bufferSource.onended = () => {
                audioSource.isPlaying = false;
            };

            return true;
        }

        getNextAudioSource() {
            for (let i = 0; i < this.poolSize; i++) {
                const index = (this.currentPoolIndex + i) % this.poolSize;
                if (!this.audioPool[index].isPlaying) {
                    this.currentPoolIndex = (index + 1) % this.poolSize;
                    return this.audioPool[index];
                }
            }
            return null;
        }

        initializeHTML5Fallback() {
            console.log('Initializing HTML5 Audio fallback');
            this.useHTML5Fallback = true;
            this.isInitialized = true;
        }

        playClickHTML5() {
            console.log(`HTML5 Audio: Playing ${this.selectedSound} click`);
            return true;
        }

        playClackHTML5() {
            console.log(`HTML5 Audio: Playing ${this.selectedSound} clack`);
            return true;
        }

        setSelectedSound(soundType) {
            if (this.audioBuffers.has(`${soundType}-click`) && this.audioBuffers.has(`${soundType}-clack`)) {
                this.selectedSound = soundType;
                return true;
            }
            return false;
        }

        cleanup() {
            if (this.audioContext) {
                this.audioContext.close();
            }
        }
    }

    // Main Pet Clicker Class
    class PetClicker {
        constructor() {
            this.selectedSound = 'snap';
            this.isClicking = false;
            this.latencyMeasurements = [];
            this.audioEngine = new AudioEngine();
            this.mobileOptimizer = new MobileOptimizer();
            this.pwaManager = new PWAManager();
            this.isAudioInitialized = false;
            this.touchId = null;

            // DOM elements
            this.clickButton = null;
            this.srAnnouncer = null;

            this.init();
        }

        async init() {
            this.setupElements();
            this.bindEvents();

            await this.initializeAudio();
            this.loadSettings();
            this.applySettings();

            this.announceToScreenReader('Pet training clicker ready');
        }

        setupElements() {
            this.clickButton = document.getElementById('click-button');
            this.srAnnouncer = document.getElementById('sr-announcer');

            this.audioEngine.setSelectedSound(this.selectedSound);
        }

        bindEvents() {
            // Enhanced touch events
            this.clickButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                this.handleEnhancedTouchStart(e);
            }, { passive: false });

            this.clickButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                this.handleEnhancedTouchEnd(e);
            }, { passive: false });

            this.clickButton.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                this.handleTouchCancel(e);
            }, { passive: false });

            // Mouse events for desktop
            this.clickButton.addEventListener('mousedown', (e) => {
                e.preventDefault();
                this.handleClickStart();
            });

            this.clickButton.addEventListener('mouseup', (e) => {
                e.preventDefault();
                this.handleClickEnd();
            });

            // Prevent context menu
            this.clickButton.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });


            // Settings button
            document.getElementById('settings-button').addEventListener('click', () => {
                this.openSettings();
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                this.handleKeyboard(e);
            });

            this.setupSettingsEvents();
        }

        setupSettingsEvents() {
            const settingsOverlay = document.getElementById('settings-overlay');
            const closeButton = document.getElementById('close-settings');

            closeButton.addEventListener('click', () => {
                this.closeSettings();
            });

            settingsOverlay.addEventListener('click', (e) => {
                if (e.target === settingsOverlay) {
                    this.closeSettings();
                }
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && settingsOverlay.classList.contains('active')) {
                    this.closeSettings();
                }
            });

            // Settings sound selector
            const settingsSoundSelector = document.getElementById('settings-sound');
            settingsSoundSelector.addEventListener('change', (e) => {
                this.selectedSound = e.target.value;
                this.audioEngine.setSelectedSound(this.selectedSound);

                setTimeout(() => {
                    this.audioEngine.playClick();
                }, 100);
            });

            // Toggle switches
            this.setupToggleSwitch('haptic-toggle', 'hapticEnabled', true);
            this.setupToggleSwitch('screenreader-toggle', 'screenReaderEnabled', true);

            // Action buttons
            document.getElementById('export-settings').addEventListener('click', () => {
                this.exportSettings();
            });

            document.getElementById('import-settings').addEventListener('click', () => {
                document.getElementById('import-file').click();
            });

            document.getElementById('import-file').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    this.importSettings(file);
                    e.target.value = '';
                }
            });

            document.getElementById('reset-all').addEventListener('click', () => {
                this.resetAllData();
            });
        }

        handleEnhancedTouchStart(event) {
            if (this.isClicking || !this.isAudioInitialized) return;

            const touch = event.touches[0];
            if (!touch) return;

            this.touchId = touch.identifier;

            if (!this.mobileOptimizer.isValidTouch(touch, this.clickButton)) {
                return;
            }

            this.handleClickStart();
        }

        handleEnhancedTouchEnd(event) {
            if (!this.isClicking) return;

            const touch = event.changedTouches[0];
            if (touch && touch.identifier !== this.touchId) return;

            this.handleClickEnd();
            this.touchId = null;
        }

        handleTouchCancel() {
            if (this.isClicking) {
                this.handleClickEnd();
            }
            this.touchId = null;
        }

        async initializeAudio() {
            try {
                const success = await this.audioEngine.initialize();

                if (success) {
                    this.isAudioInitialized = true;
                    console.log('Audio system initialized successfully');
                } else {
                    this.isAudioInitialized = true;
                    console.log('Audio system using HTML5 fallback');
                }
            } catch (error) {
                console.error('Audio initialization failed:', error);
            }
        }

        handleClickStart() {
            if (this.isClicking || !this.isAudioInitialized) return;

            const startTime = performance.now();
            this.isClicking = true;

            this.clickButton.classList.add('clicking');

            if (this.mobileOptimizer.hapticSupported) {
                this.mobileOptimizer.triggerHaptic('click');
            }

            this.clickButton.classList.add('haptic-pulse');
            setTimeout(() => {
                this.clickButton.classList.remove('haptic-pulse');
            }, 100);

            const audioSuccess = this.audioEngine.playClick();

            if (audioSuccess) {
                const endTime = performance.now();
                this.recordLatency(endTime - startTime);
            } else {
                this.mobileOptimizer.triggerHaptic('error');
            }
        }

        handleClickEnd() {
            if (!this.isClicking) return;

            this.isClicking = false;
            this.clickButton.classList.remove('clicking');

            if (this.mobileOptimizer.hapticSupported) {
                this.mobileOptimizer.triggerHaptic('clack');
            }

            const audioSuccess = this.audioEngine.playClack();

            if (!audioSuccess) {
                this.mobileOptimizer.triggerHaptic('error');
            }
        }

        handleKeyboard(event) {
            if (event.code === 'Space' || event.code === 'Enter') {
                event.preventDefault();
                if (!this.isClicking) {
                    this.handleClickStart();
                    setTimeout(() => this.handleClickEnd(), 150);
                }
            }

            if (event.code === 'KeyM') {
                event.preventDefault();
                this.cycleSoundType();
            }
        }

        cycleSoundType() {
            const sounds = ['snap', 'metal', 'plastic', 'box'];
            const currentIndex = sounds.indexOf(this.selectedSound);
            const nextIndex = (currentIndex + 1) % sounds.length;

            this.selectedSound = sounds[nextIndex];
            this.audioEngine.setSelectedSound(this.selectedSound);
            this.announceToScreenReader(`Sound changed to ${this.selectedSound} clicker`);
        }

        recordLatency(latency) {
            this.latencyMeasurements.push(latency);
            if (this.latencyMeasurements.length > 50) {
                this.latencyMeasurements.shift();
            }
            this.updateLatencyDisplay();
        }

        getAverageLatency() {
            if (this.latencyMeasurements.length === 0) return 0;
            const sum = this.latencyMeasurements.reduce((a, b) => a + b, 0);
            return sum / this.latencyMeasurements.length;
        }

        updateLatencyDisplay() {
            // Latency tracking continues for internal purposes but no display
            // No UI update needed since display is removed
        }

        setupToggleSwitch(toggleId, settingKey, defaultValue) {
            const toggle = document.getElementById(toggleId);
            let isEnabled = this.getSetting(settingKey, defaultValue);

            toggle.classList.toggle('active', isEnabled);

            toggle.addEventListener('click', () => {
                isEnabled = !isEnabled;
                toggle.classList.toggle('active', isEnabled);
                this.setSetting(settingKey, isEnabled);
                this.applySettings();
            });
        }

        openSettings() {
            const settingsOverlay = document.getElementById('settings-overlay');
            settingsOverlay.classList.add('active');

            this.updateSettingsPanel();

            setTimeout(() => {
                document.getElementById('close-settings').focus();
            }, 100);

            this.announceToScreenReader('Settings opened');
        }

        closeSettings() {
            const settingsOverlay = document.getElementById('settings-overlay');
            settingsOverlay.classList.remove('active');

            document.getElementById('settings-button').focus();
            this.announceToScreenReader('Settings closed');
        }

        updateSettingsPanel() {
            document.getElementById('settings-sound').value = this.selectedSound;

            const audioEngineInfo = document.getElementById('audio-engine-info');
            if (this.audioEngine.useHTML5Fallback) {
                audioEngineInfo.textContent = 'HTML5 Audio';
                audioEngineInfo.className = 'info-value status-warning';
            } else {
                audioEngineInfo.textContent = 'Web Audio API';
                audioEngineInfo.className = 'info-value status-good';
            }

            const installStatus = document.getElementById('install-status');
            if (this.pwaManager.isInstalled) {
                installStatus.textContent = 'Installed';
                installStatus.className = 'info-value status-good';
            } else {
                installStatus.textContent = 'Browser';
                installStatus.className = 'info-value';
            }
        }

        loadSettings() {
            try {
                const settings = localStorage.getItem('pet-clicker-settings');
                if (settings) {
                    const parsed = JSON.parse(settings);

                    if (parsed.selectedSound) {
                        this.selectedSound = parsed.selectedSound;
                        this.audioEngine.setSelectedSound(this.selectedSound);
                    }
                }
            } catch (error) {
                console.log('Could not load settings:', error);
            }
        }

        saveSettings() {
            try {
                const settings = {
                    selectedSound: this.selectedSound,
                    lastSession: new Date().toISOString()
                };

                localStorage.setItem('pet-clicker-settings', JSON.stringify(settings));
            } catch (error) {
                console.log('Could not save settings:', error);
            }
        }

        getSetting(key, defaultValue) {
            try {
                const settings = JSON.parse(localStorage.getItem('pet-clicker-settings') || '{}');
                return settings[key] !== undefined ? settings[key] : defaultValue;
            } catch {
                return defaultValue;
            }
        }

        setSetting(key, value) {
            try {
                const settings = JSON.parse(localStorage.getItem('pet-clicker-settings') || '{}');
                settings[key] = value;
                localStorage.setItem('pet-clicker-settings', JSON.stringify(settings));
            } catch (error) {
                console.warn('Could not save setting:', error);
            }
        }

        applySettings() {
            const hapticEnabled = this.getSetting('hapticEnabled', true);
            this.mobileOptimizer.hapticSupported = hapticEnabled && 'vibrate' in navigator;

            this.screenReaderEnabled = this.getSetting('screenReaderEnabled', true);
        }

        announceToScreenReader(message) {
            if (this.screenReaderEnabled && this.srAnnouncer) {
                this.srAnnouncer.textContent = message;
            }
        }

        exportSettings() {
            const settings = {
                selectedSound: this.selectedSound,
                exportDate: new Date().toISOString(),
                version: '2.0.0'
            };

            const dataStr = JSON.stringify(settings, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });

            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'pet-clicker-settings.json';
            link.click();

            URL.revokeObjectURL(url);
        }

        async importSettings(file) {
            try {
                const text = await file.text();
                const settings = JSON.parse(text);

                if (settings.selectedSound && ['snap', 'metal', 'plastic', 'box'].includes(settings.selectedSound)) {
                    this.selectedSound = settings.selectedSound;
                    this.audioEngine.setSelectedSound(this.selectedSound);
                }

                this.saveSettings();
                this.announceToScreenReader('Settings imported successfully');

            } catch (error) {
                console.error('Failed to import settings:', error);
                this.announceToScreenReader('Failed to import settings');
            }
        }

        resetAllData() {
            if (confirm('Reset all settings?')) {
                this.selectedSound = 'snap';

                this.audioEngine.setSelectedSound(this.selectedSound);

                try {
                    localStorage.removeItem('pet-clicker-settings');
                } catch (error) {
                    console.log('Could not clear settings:', error);
                }

                this.announceToScreenReader('All settings reset');
            }
        }

        destroy() {
            this.saveSettings();

            if (this.audioEngine) {
                this.audioEngine.cleanup();
            }
        }
    }

    // Application Lifecycle Management
    let petClicker = null;

    document.addEventListener('DOMContentLoaded', () => {
        petClicker = new PetClicker();
    });

    window.addEventListener('orientationchange', () => {
        setTimeout(() => {
            if (petClicker?.mobileOptimizer) {
                window.scrollTo(0, 0);
            }
        }, 500);
    });

    document.addEventListener('visibilitychange', () => {
        if (petClicker?.audioEngine?.audioContext) {
            if (document.hidden) {
                petClicker.audioEngine.audioContext.suspend();
            } else {
                petClicker.audioEngine.audioContext.resume();
            }
        }
    });

    window.addEventListener('beforeunload', () => {
        petClicker?.destroy();
    });

    document.addEventListener('gesturestart', (e) => {
        e.preventDefault();
    });

    // Wake Lock Management
    class WakeLockManager {
        constructor() {
            this.wakeLock = null;
            this.supported = 'wakeLock' in navigator;
            this.requested = false;
            this.init();
        }

        init() {
            this.setupEventListeners();
        }

        setupEventListeners() {
            document.addEventListener('visibilitychange', async () => {
                if (this.supported && this.wakeLock !== null && document.visibilityState === 'visible') {
                    try {
                        this.wakeLock = await navigator.wakeLock.request('screen');
                    } catch (err) {
                        // Silent fail
                    }
                }
            });

            document.addEventListener('DOMContentLoaded', () => {
                const clickButton = document.getElementById('click-button');
                if (clickButton) {
                    clickButton.addEventListener('click', () => this.requestWakeLock(), { once: true });
                    clickButton.addEventListener('touchstart', () => this.requestWakeLock(), { once: true });
                }
            });
        }

        async requestWakeLock() {
            if (this.requested || !this.supported) return;
            
            this.requested = true;
            try {
                this.wakeLock = await navigator.wakeLock.request('screen');
                console.log('Screen wake lock active');

                this.wakeLock.addEventListener('release', () => {
                    console.log('Screen wake lock released');
                });
            } catch (err) {
                console.log('Wake lock not available');
                this.supported = false;
            }
        }
    }

    new WakeLockManager();
</script>

</body>
</html>