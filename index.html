<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#2196F3">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Pet Clicker">
    <meta name="description" content="Professional pet training clicker with ultra-low latency audio for dogs and cats">

```
<!-- PWA Manifest -->
<link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIlBldCBUcmFpbmluZyBDbGlja2VyIiwKICAic2hvcnRfbmFtZSI6ICJQZXRDbGlja2VyIiwKICAiZGVzY3JpcHRpb24iOiAiUHJvZmVzc2lvbmFsIHBldCB0cmFpbmluZyBjbGlja2VyIHdpdGggdWx0cmEtbG93IGxhdGVuY3kgYXVkaW8iLAogICJzdGFydF91cmwiOiAiLyIsCiAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgIm9yaWVudGF0aW9uIjogInBvcnRyYWl0IiwKICAidGhlbWVfY29sb3IiOiAiIzIxOTZGMyIsCiAgImJhY2tncm91bmRfY29sb3IiOiAiI2ZmZmZmZiIsCiAgImNhdGVnb3JpZXMiOiBbInBldHMiLCAidHJhaW5pbmciLCAidG9vbHMiXSwKICAibGFuZyI6ICJlbiIsCiAgImljb25zIjogWwogICAgewogICAgICAic3JjIjogImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UazJJaUJvWldsbmFIUTlJakU1TmlJZ2RtbGxkMEp2ZUQwaU1DQXdJREU1TmlBeE9UWWlJR1pwYkd3OUlpTXlNVGsyUmpNaVBnb2dJRHhqYVhKamJHVWdZM2c5SWprNElpQmplVDBpT1RnaUlISTlJekl3SWlCbWFXeHNQU0lqWm1abUlpOCtDaUFnUEdOcGNtTnNaU0JqZUQwaU9UZ2lJR041UFNJNFppSWdjajBpTVRVaUlHWnBiR3c5SWlNeU1UazJSak1pTHo0S1BDOXpkbWMrIiwKICAgICAgInNpemVzIjogIjE5MngxOTIiLAogICAgICAidHlwZSI6ICJpbWFnZS9zdmcreG1sIiwKICAgICAgInB1cnBvc2UiOiAiYW55IG1hc2thYmxlIgogICAgfSwKICAgIHsKICAgICAgInNyYyI6ICJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlOVEV5SWlCb1pXbG5hSFE5SWpVeE1pSWdkbWxsZDBKdmVEMGlNQ0F3SURRNE1DQTBPREFpSUdacGJHdzlJaU15TVRrMlJqTWlQZ29nSUR4amFYSmpiR1VnWTNnOUlqSTBNQ0lnWTNrOUlqSTBNQ0lnY2owaU1UQXdJaUJtYVd4c1BTSWpabVptSWk4K0NpQWdQR05wY21Oc1pTQmplRDBpTWpRd0lpQmplVDBpTVRrd0lpQnlQU0kzTUNJZ1ptbHNiRDBpSXpJeE9UWkdNeUl2UGdvOEwzTjJaejQiLAogICAgICAic2l6ZXMiOiAiNTEyeDUxMiIsCiAgICAgICJ0eXBlIjogImltYWdlL3N2Zyt4bWwiLAogICAgICAicHVycG9zZSI6ICJhbnkgbWFza2FibGUiCiAgICB9CiAgXSwKICAic2hvcnRjdXRzIjogWwogICAgewogICAgICAibmFtZSI6ICJRdWljayBDbGljayIsCiAgICAgICJ1cmwiOiAiLz9xdWljaz10cnVlIiwKICAgICAgImRlc2NyaXB0aW9uIjogIk9wZW4gY2xpY2tlciByZWFkeSB0byB1c2UiCiAgICB9CiAgXQp9">

<!-- iOS Icons -->
<link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTk2IiBoZWlnaHQ9IjE5NiIgdmlld0JveD0iMCAwIDE5NiAxOTYiIGZpbGw9IiMyMTk2RjMiPgogIDxjaXJjbGUgY3g9Ijk4IiBjeT0iOTgiIHI9IjIwIiBmaWxsPSIjZmZmIi8+CiAgPGNpcmNsZSBjeD0iOTgiIGN5PSI4ZiIgcj0iMTUiIGZpbGw9IiMyMTk2RjMiLz4KPC9zdmc+">

<title>Pet Training Clicker</title>

<style>
    /* CSS Variables - Design System */
    :root {
        /* Primary Colors */
        --primary-blue: #2196F3;
        --primary-blue-dark: #1976D2;
        --primary-blue-light: #E3F2FD;
        
        /* Neutral Colors */
        --white: #FFFFFF;
        --gray-50: #FAFAFA;
        --gray-100: #F5F5F5;
        --gray-200: #EEEEEE;
        --gray-400: #BDBDBD;
        --gray-600: #757575;
        --gray-900: #212121;
        
        /* Feedback Colors */
        --success-green: #4CAF50;
        --warning-orange: #FF9800;
        --error-red: #F44336;
        
        /* High Contrast Mode */
        --hc-background: #000000;
        --hc-foreground: #FFFFFF;
        --hc-accent: #FFFF00;
        
        /* Typography */
        --font-primary: -apple-system, BlinkMacSystemFont, 'Segoe UI', 
                        Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        --text-xs: 12px;
        --text-sm: 14px;
        --text-base: 16px;
        --text-lg: 18px;
        --text-xl: 24px;
        --text-2xl: 32px;
    }

    /* Reset and Base Styles */
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body {
        font-family: var(--font-primary);
        background: var(--gray-50);
        color: var(--gray-900);
        line-height: 1.5;
        overflow-x: hidden;
        -webkit-tap-highlight-color: transparent;
    }

    /* Main Container */
    .container {
        width: 100%;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
        position: relative;
    }

    /* App Header */
    .app-header {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        text-align: center;
    }

    .app-title {
        font-size: var(--text-lg);
        font-weight: 600;
        color: var(--gray-600);
        margin-bottom: 4px;
    }

    .app-subtitle {
        font-size: var(--text-sm);
        color: var(--gray-400);
    }

    /* Mobile Optimization Styles */
    
    /* Enhanced Touch Targets */
    .click-button {
        width: min(300px, 80vw);
        height: min(300px, 80vw);
        max-height: 50vh;
        
        background: linear-gradient(135deg, var(--primary-blue) 0%, var(--primary-blue-dark) 100%);
        border: none;
        border-radius: 50%;
        
        color: var(--white);
        font-size: var(--text-xl);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 2px;
        
        cursor: pointer;
        touch-action: manipulation;
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
        
        box-shadow: 
            0 8px 16px rgba(33, 150, 243, 0.3),
            0 2px 4px rgba(0, 0, 0, 0.1);
        
        transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
        
        /* Enhanced for mobile touch */
        min-height: 44px; /* iOS accessibility minimum */
        min-width: 44px;
    }

    /* Enhanced Active State for Mobile */
    .click-button:active,
    .click-button.clicking {
        transform: scale(0.95);
        box-shadow: 
            0 4px 8px rgba(33, 150, 243, 0.4),
            0 1px 2px rgba(0, 0, 0, 0.2);
    }

    /* iOS Specific Optimizations */
    @supports (-webkit-touch-callout: none) {
        .click-button {
            -webkit-appearance: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: rgba(0,0,0,0);
        }
        
        /* Prevent iOS zoom on focus */
        input, select, textarea {
            font-size: 16px;
        }
    }

    /* Android Specific Optimizations */
    @media screen and (-webkit-min-device-pixel-ratio: 0) {
        .click-button {
            /* Improve touch response on Android */
            will-change: transform;
        }
    }

    /* Enhanced Control Buttons for Mobile */
    .control-button {
        width: 56px;
        height: 56px;
        border-radius: 12px;
        border: 1px solid var(--gray-200);
        background: var(--white);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        font-size: var(--text-sm);
        font-weight: 500;
        
        /* Mobile touch optimizations */
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        min-height: 44px;
        min-width: 44px;
    }

    /* Enhanced Volume Slider for Mobile */
    .volume-slider {
        width: 100px;
        height: 44px; /* Larger touch target */
        background: transparent;
        border-radius: 22px;
        outline: none;
        cursor: pointer;
        -webkit-appearance: none;
        appearance: none;
        position: relative;
    }

    .volume-slider::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 0;
        right: 0;
        height: 6px;
        background: var(--gray-200);
        border-radius: 3px;
        transform: translateY(-50%);
    }

    .volume-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: var(--primary-blue);
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        position: relative;
        z-index: 2;
    }

    .volume-slider::-moz-range-thumb {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: var(--primary-blue);
        cursor: pointer;
        border: none;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    /* Mobile Landscape Optimizations */
    @media (orientation: landscape) and (max-height: 500px) {
        .container {
            padding: 10px;
        }
        
        .app-header {
            position: static;
            margin-bottom: 10px;
        }
        
        .app-title {
            font-size: var(--text-base);
        }
        
        .app-subtitle {
            display: none; /* Hide subtitle in tight landscape */
        }
        
        .click-button {
            width: min(200px, 40vw);
            height: min(200px, 60vh);
            font-size: var(--text-lg);
        }
        
        .control-panel {
            margin-top: 20px;
            gap: 12px;
        }
        
        .status-panel {
            font-size: 10px;
            gap: 15px;
        }
    }

    /* Haptic Feedback Enhancement Indicator */
    .haptic-pulse {
        animation: haptic-pulse 0.1s ease-out;
    }

    @keyframes haptic-pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.02); }
        100% { transform: scale(1); }
    }

    /* Loading State for Mobile */
    .mobile-loading {
        pointer-events: none;
        opacity: 0.7;
    }

    .mobile-loading .click-button {
        background: var(--gray-400);
    }

    /* PWA Specific Styles */
    
    /* Install Button */
    .install-button {
        background: linear-gradient(135deg, var(--success-green) 0%, #388E3C 100%);
        color: var(--white);
        border: none;
    }

    .install-button:hover {
        background: linear-gradient(135deg, #388E3C 0%, var(--success-green) 100%);
    }

    /* Update Notification */
    .update-notification {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--primary-blue);
        color: var(--white);
        padding: 16px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        animation: slideIn 0.3s ease-out;
    }

    .update-content {
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: var(--text-sm);
    }

    .update-button, .dismiss-button {
        background: var(--white);
        color: var(--primary-blue);
        border: none;
        padding: 6px 12px;
        border-radius: 4px;
        font-size: var(--text-xs);
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .update-button:hover {
        background: var(--gray-100);
    }

    .dismiss-button {
        background: transparent;
        color: var(--white);
        border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .dismiss-button:hover {
        background: rgba(255, 255, 255, 0.1);
    }

    @keyframes slideIn {
        from {
            transform: translateX(-50%) translateY(-100%);
            opacity: 0;
        }
        to {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
    }

    /* Offline Mode Styles */
    .offline .click-button {
        background: linear-gradient(135deg, var(--gray-400) 0%, var(--gray-600) 100%);
    }

    .offline .app-header::after {
        content: ' (Offline)';
        color: var(--warning-orange);
        font-size: var(--text-sm);
    }

    /* PWA Installed Styles */
    .pwa-installed .app-header {
        padding-top: env(safe-area-inset-top, 0);
    }

    /* Settings Panel Styles */
    .settings-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
    }

    .settings-overlay.active {
        opacity: 1;
        visibility: visible;
    }

    .settings-panel {
        background: var(--white);
        border-radius: 16px;
        padding: 24px;
        width: min(400px, 90vw);
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
        transform: translateY(20px);
        transition: transform 0.3s ease;
    }

    .settings-overlay.active .settings-panel {
        transform: translateY(0);
    }

    .settings-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 1px solid var(--gray-200);
    }

    .settings-title {
        font-size: var(--text-xl);
        font-weight: 600;
        color: var(--gray-900);
    }

    .close-button {
        background: none;
        border: none;
        font-size: 24px;
        color: var(--gray-400);
        cursor: pointer;
        padding: 4px;
        border-radius: 4px;
        transition: all 0.2s ease;
    }

    .close-button:hover {
        background: var(--gray-100);
        color: var(--gray-600);
    }

    .settings-section {
        margin-bottom: 24px;
    }

    .settings-section:last-child {
        margin-bottom: 0;
    }

    .section-title {
        font-size: var(--text-lg);
        font-weight: 600;
        color: var(--gray-900);
        margin-bottom: 12px;
    }

    .setting-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 0;
        border-bottom: 1px solid var(--gray-100);
    }

    .setting-item:last-child {
        border-bottom: none;
    }

    .setting-label {
        flex: 1;
        margin-right: 16px;
    }

    .setting-name {
        font-weight: 500;
        color: var(--gray-900);
        margin-bottom: 2px;
    }

    .setting-description {
        font-size: var(--text-sm);
        color: var(--gray-600);
    }

    .setting-control {
        flex-shrink: 0;
    }

    .toggle-switch {
        position: relative;
        width: 44px;
        height: 24px;
        background: var(--gray-300);
        border-radius: 12px;
        cursor: pointer;
        transition: background 0.3s ease;
    }

    .toggle-switch.active {
        background: var(--primary-blue);
    }

    .toggle-switch::before {
        content: '';
        position: absolute;
        top: 2px;
        left: 2px;
        width: 20px;
        height: 20px;
        background: var(--white);
        border-radius: 50%;
        transition: transform 0.3s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .toggle-switch.active::before {
        transform: translateX(20px);
    }

    .action-button {
        background: var(--primary-blue);
        color: var(--white);
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        font-size: var(--text-sm);
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .action-button:hover {
        background: var(--primary-blue-dark);
    }

    .action-button.secondary {
        background: var(--gray-100);
        color: var(--gray-700);
    }

    .action-button.secondary:hover {
        background: var(--gray-200);
    }

    .action-button.danger {
        background: var(--error-red);
    }

    .action-button.danger:hover {
        background: #D32F2F;
    }

    .info-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
        margin-top: 16px;
    }

    .info-card {
        background: var(--gray-50);
        padding: 12px;
        border-radius: 8px;
        text-align: center;
    }

    .info-value {
        font-size: var(--text-lg);
        font-weight: 600;
        color: var(--primary-blue);
    }

    .info-label {
        font-size: var(--text-xs);
        color: var(--gray-600);
        margin-top: 4px;
    }

    /* Ripple Effect */
    .click-button::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.5);
        transform: translate(-50%, -50%);
        pointer-events: none;
    }

    .click-button.clicking::before {
        animation: ripple 0.6s linear;
    }

    /* Control Panel */
    .control-panel {
        display: flex;
        gap: 16px;
        justify-content: center;
        margin-top: 40px;
        flex-wrap: wrap;
    }

    .control-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        min-width: 80px;
    }

    .control-label {
        font-size: var(--text-sm);
        color: var(--gray-600);
        font-weight: 500;
    }

    .control-button {
        width: 56px;
        height: 56px;
        border-radius: 12px;
        border: 1px solid var(--gray-200);
        background: var(--white);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        font-size: var(--text-sm);
        font-weight: 500;
    }

    .control-button:hover {
        border-color: var(--primary-blue);
        box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2);
    }

    .control-button.active {
        background: var(--primary-blue);
        border-color: var(--primary-blue);
        color: var(--white);
    }

    /* Volume Slider */
    .volume-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
    }

    .volume-slider {
        width: 100px;
        height: 6px;
        background: var(--gray-200);
        border-radius: 3px;
        outline: none;
        cursor: pointer;
        -webkit-appearance: none;
        appearance: none;
    }

    .volume-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--primary-blue);
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .volume-slider::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--primary-blue);
        cursor: pointer;
        border: none;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .volume-value {
        font-size: var(--text-xs);
        color: var(--gray-400);
        min-width: 30px;
        text-align: center;
    }

    /* Status Display */
    .status-panel {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 20px;
        font-size: var(--text-xs);
        color: var(--gray-600);
        text-align: center;
    }

    .status-item {
        display: flex;
        flex-direction: column;
        gap: 2px;
    }

    .status-value {
        font-weight: 600;
        color: var(--gray-900);
    }

    .status-good { color: var(--success-green); }
    .status-warning { color: var(--warning-orange); }
    .status-error { color: var(--error-red); }

    /* Screen Reader Only */
    .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
    }

    /* High Contrast Mode */
    .high-contrast {
        background: var(--hc-background);
        color: var(--hc-foreground);
    }

    .high-contrast .click-button {
        background: var(--hc-accent);
        color: var(--hc-background);
        border: 3px solid var(--hc-foreground);
    }

    .high-contrast .control-button {
        background: var(--hc-background);
        color: var(--hc-foreground);
        border: 2px solid var(--hc-foreground);
    }

    .high-contrast .control-button.active {
        background: var(--hc-accent);
        color: var(--hc-background);
    }

    /* Animations */
    @keyframes click-pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
    }

    @keyframes ripple {
        0% {
            width: 0;
            height: 0;
            opacity: 1;
        }
        100% {
            width: 400px;
            height: 400px;
            opacity: 0;
        }
    }

    /* Responsive Design */
    @media (min-width: 481px) and (orientation: landscape) {
        .container {
            flex-direction: row;
            gap: 40px;
            padding: 30px;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .control-panel {
            flex-direction: column;
            margin-top: 0;
            margin-left: 0;
        }

        .app-header {
            position: static;
            transform: none;
            margin-bottom: 20px;
        }
    }

    @media (min-width: 769px) {
        .container {
            max-width: 600px;
            margin: 0 auto;
            flex-direction: column;
            padding: 40px;
        }

        .click-button {
            width: 320px;
            height: 320px;
            max-height: none;
        }

        .control-panel {
            flex-direction: row;
            gap: 24px;
            margin-top: 50px;
        }

        .status-panel {
            position: static;
            transform: none;
            margin-top: 30px;
            padding: 16px;
            background: var(--white);
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
    }

    /* Loading State */
    .loading {
        opacity: 0.7;
        pointer-events: none;
    }

    .loading-spinner {
        width: 24px;
        height: 24px;
        border: 2px solid var(--gray-200);
        border-top: 2px solid var(--primary-blue);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
</style>
```

</head>
<body>
    <div class="container">
        <!-- App Header -->
        <header class="app-header">
            <h1 class="app-title">Pet Training Clicker</h1>
            <p class="app-subtitle">Professional clicker for dogs & cats</p>
        </header>

```
    <!-- Main Content -->
    <main class="main-content">
        <!-- Primary Click Button -->
        <button 
            id="click-button" 
            class="click-button" 
            aria-label="Pet training clicker - Press to make click sound"
            role="button"
        >
            CLICK
        </button>

        <!-- Control Panel -->
        <div class="control-panel">
            <!-- Sound Type Selector -->
            <div class="control-item">
                <label class="control-label" for="sound-selector">Sound</label>
                <select id="sound-selector" class="control-button" style="width: 80px; text-align: center;">
                    <option value="metal">Metal</option>
                    <option value="plastic">Plastic</option>
                    <option value="box">Box</option>
                    <option value="snap">Snap</option>
                </select>
            </div>

            <!-- Volume Control -->
            <div class="control-item">
                <label class="control-label" for="volume-slider">Volume</label>
                <div class="volume-container">
                    <input 
                        type="range" 
                        id="volume-slider" 
                        class="volume-slider"
                        min="0" 
                        max="1" 
                        step="0.1" 
                        value="0.8"
                        aria-label="Volume control"
                    >
                    <span id="volume-value" class="volume-value">80%</span>
                </div>
            </div>

            <!-- Settings Button -->
            <div class="control-item">
                <span class="control-label">Settings</span>
                <button 
                    id="settings-button" 
                    class="control-button"
                    aria-label="Open settings"
                >
                    ‚öôÔ∏è
                </button>
            </div>
        </div>
    </main>

    <!-- Settings Panel -->
    <div id="settings-overlay" class="settings-overlay">
        <div class="settings-panel">
            <div class="settings-header">
                <h2 class="settings-title">Settings</h2>
                <button id="close-settings" class="close-button" aria-label="Close settings">√ó</button>
            </div>

            <!-- Audio Settings -->
            <div class="settings-section">
                <h3 class="section-title">Audio Settings</h3>
                
                <div class="setting-item">
                    <div class="setting-label">
                        <div class="setting-name">Master Volume</div>
                        <div class="setting-description">Overall clicker volume</div>
                    </div>
                    <div class="setting-control">
                        <input 
                            type="range" 
                            id="settings-volume" 
                            min="0" 
                            max="1" 
                            step="0.1" 
                            value="0.8"
                            style="width: 100px;"
                        >
                        <span id="settings-volume-value">80%</span>
                    </div>
                </div>

                <div class="setting-item">
                    <div class="setting-label">
                        <div class="setting-name">Clicker Type</div>
                        <div class="setting-description">Sound characteristics</div>
                    </div>
                    <div class="setting-control">
                        <select id="settings-sound" style="padding: 4px 8px; border-radius: 4px;">
                            <option value="metal">Metal (Sharp)</option>
                            <option value="plastic">Plastic (Soft)</option>
                            <option value="box">Box (Loud)</option>
                            <option value="snap">Snap (Natural)</option>
                        </select>
                    </div>
                </div>

                <div class="setting-item">
                    <div class="setting-label">
                        <div class="setting-name">Audio Engine</div>
                        <div class="setting-description">Current audio system</div>
                    </div>
                    <div class="setting-control">
                        <span id="audio-engine-info" class="info-value">Web Audio API</span>
                    </div>
                </div>
            </div>

            <!-- Accessibility Settings -->
            <div class="settings-section">
                <h3 class="section-title">Accessibility</h3>
                
                <div class="setting-item">
                    <div class="setting-label">
                        <div class="setting-name">Haptic Feedback</div>
                        <div class="setting-description">Vibration on button press</div>
                    </div>
                    <div class="setting-control">
                        <div id="haptic-toggle" class="toggle-switch active"></div>
                    </div>
                </div>

                <div class="setting-item">
                    <div class="setting-label">
                        <div class="setting-name">Screen Reader</div>
                        <div class="setting-description">Voice announcements</div>
                    </div>
                    <div class="setting-control">
                        <div id="screenreader-toggle" class="toggle-switch active"></div>
                    </div>
                </div>

                <div class="setting-item">
                    <div class="setting-label">
                        <div class="setting-name">Performance Display</div>
                        <div class="setting-description">Show latency information</div>
                    </div>
                    <div class="setting-control">
                        <div id="performance-toggle" class="toggle-switch active"></div>
                    </div>
                </div>
            </div>

            <!-- Statistics -->
            <div class="settings-section">
                <h3 class="section-title">Session Statistics</h3>
                
                <div class="info-grid">
                    <div class="info-card">
                        <div id="total-clicks" class="info-value">0</div>
                        <div class="info-label">Total Clicks</div>
                    </div>
                    <div class="info-card">
                        <div id="avg-latency" class="info-value">--ms</div>
                        <div class="info-label">Avg Latency</div>
                    </div>
                    <div class="info-card">
                        <div id="session-time" class="info-value">0m</div>
                        <div class="info-label">Session Time</div>
                    </div>
                    <div class="info-card">
                        <div id="clicks-per-min" class="info-value">0</div>
                        <div class="info-label">Clicks/Min</div>
                    </div>
                </div>
            </div>

            <!-- Data Management -->
            <div class="settings-section">
                <h3 class="section-title">Data Management</h3>
                
                <div class="setting-item">
                    <div class="setting-label">
                        <div class="setting-name">Export Settings</div>
                        <div class="setting-description">Download backup file</div>
                    </div>
                    <div class="setting-control">
                        <button id="export-settings" class="action-button">Export</button>
                    </div>
                </div>

                <div class="setting-item">
                    <div class="setting-label">
                        <div class="setting-name">Import Settings</div>
                        <div class="setting-description">Restore from backup</div>
                    </div>
                    <div class="setting-control">
                        <input type="file" id="import-file" accept=".json" style="display: none;">
                        <button id="import-settings" class="action-button secondary">Import</button>
                    </div>
                </div>

                <div class="setting-item">
                    <div class="setting-label">
                        <div class="setting-name">Reset Counter</div>
                        <div class="setting-description">Clear click count only</div>
                    </div>
                    <div class="setting-control">
                        <button id="reset-counter" class="action-button secondary">Reset</button>
                    </div>
                </div>

                <div class="setting-item">
                    <div class="setting-label">
                        <div class="setting-name">Reset All Data</div>
                        <div class="setting-description">Clear everything</div>
                    </div>
                    <div class="setting-control">
                        <button id="reset-all" class="action-button danger">Reset All</button>
                    </div>
                </div>
            </div>

            <!-- App Information -->
            <div class="settings-section">
                <h3 class="section-title">App Information</h3>
                
                <div class="setting-item">
                    <div class="setting-label">
                        <div class="setting-name">Version</div>
                        <div class="setting-description">App version</div>
                    </div>
                    <div class="setting-control">
                        <span class="info-value">1.0.0</span>
                    </div>
                </div>

                <div class="setting-item">
                    <div class="setting-label">
                        <div class="setting-name">Installation</div>
                        <div class="setting-description">App install status</div>
                    </div>
                    <div class="setting-control">
                        <span id="install-status" class="info-value">Browser</span>
                    </div>
                </div>

                <div class="setting-item">
                    <div class="setting-label">
                        <div class="setting-name">Storage Used</div>
                        <div class="setting-description">Cache and settings</div>
                    </div>
                    <div class="setting-control">
                        <span id="storage-info" class="info-value">--KB</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Status Panel -->
    <div class="status-panel">
        <div class="status-item">
            <span class="status-label">Clicks</span>
            <span id="click-count" class="status-value">0</span>
        </div>
        <div class="status-item">
            <span class="status-label">Latency</span>
            <span id="latency-display" class="status-value">--ms</span>
        </div>
        <div class="status-item">
            <span class="status-label">Status</span>
            <span id="audio-status" class="status-value">Ready</span>
        </div>
    </div>

    <!-- Screen Reader Announcements -->
    <div id="sr-announcer" class="sr-only" aria-live="polite" aria-atomic="true"></div>
</div>

<script>
    // PWA Service Worker Registration and Management
    class PWAManager {
        constructor() {
            this.isOnline = navigator.onLine;
            this.deferredPrompt = null;
            this.isInstalled = false;
            this.updateAvailable = false;
            
            this.init();
        }

        async init() {
            // Register service worker
            await this.registerServiceWorker();
            
            // Setup install prompt handling
            this.setupInstallPrompt();
            
            // Setup online/offline detection
            this.setupOnlineDetection();
            
            // Setup update detection
            this.setupUpdateDetection();
            
            // Check if already installed
            this.checkInstallStatus();
        }

        async registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                try {
                    // Register inline service worker
                    const swCode = this.generateServiceWorkerCode();
                    const blob = new Blob([swCode], { type: 'application/javascript' });
                    const swUrl = URL.createObjectURL(blob);
                    
                    const registration = await navigator.serviceWorker.register(swUrl);
                    console.log('Service Worker registered successfully');
                    
                    // Setup update listener
                    registration.addEventListener('updatefound', () => {
                        const newWorker = registration.installing;
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                this.updateAvailable = true;
                                this.showUpdatePrompt();
                            }
                        });
                    });
                    
                    return registration;
                } catch (error) {
                    console.log('Service Worker registration failed:', error);
                }
            }
        }

        generateServiceWorkerCode() {
            return `
                const CACHE_NAME = 'pet-clicker-v1.0.0';
                const AUDIO_CACHE = 'pet-clicker-audio-v1.0.0';
                
                // Install event - cache core resources
                self.addEventListener('install', (event) => {
                    event.waitUntil(
                        caches.open(CACHE_NAME).then((cache) => {
                            // Cache the main page and essential resources
                            return cache.add(new Request(self.location.href));
                        })
                    );
                    self.skipWaiting();
                });
                
                // Activate event - clean up old caches
                self.addEventListener('activate', (event) => {
                    event.waitUntil(
                        caches.keys().then((cacheNames) => {
                            return Promise.all(
                                cacheNames.map((cacheName) => {
                                    if (cacheName !== CACHE_NAME && cacheName !== AUDIO_CACHE) {
                                        return caches.delete(cacheName);
                                    }
                                })
                            );
                        })
                    );
                    self.clients.claim();
                });
                
                // Fetch event - serve from cache, fallback to network
                self.addEventListener('fetch', (event) => {
                    if (event.request.method !== 'GET') return;
                    
                    event.respondWith(
                        caches.match(event.request).then((response) => {
                            if (response) {
                                return response;
                            }
                            
                            return fetch(event.request).then((response) => {
                                // Don't cache non-successful responses
                                if (!response || response.status !== 200 || response.type !== 'basic') {
                                    return response;
                                }
                                
                                const responseToCache = response.clone();
                                caches.open(CACHE_NAME).then((cache) => {
                                    cache.put(event.request, responseToCache);
                                });
                                
                                return response;
                            });
                        }).catch(() => {
                            // Return offline page for navigation requests
                            if (event.request.mode === 'navigate') {
                                return new Response(
                                    '<h1>Offline</h1><p>Pet Clicker is cached and ready to use offline!</p>',
                                    { headers: { 'Content-Type': 'text/html' } }
                                );
                            }
                        })
                    );
                });
            `;
        }

        setupInstallPrompt() {
            // Listen for beforeinstallprompt event
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                this.deferredPrompt = e;
                this.showInstallButton();
            });

            // Listen for app installation
            window.addEventListener('appinstalled', () => {
                this.isInstalled = true;
                this.hideInstallButton();
                this.showInstallSuccess();
            });
        }

        setupOnlineDetection() {
            window.addEventListener('online', () => {
                this.isOnline = true;
                this.updateOnlineStatus();
            });

            window.addEventListener('offline', () => {
                this.isOnline = false;
                this.updateOnlineStatus();
            });

            this.updateOnlineStatus();
        }

        setupUpdateDetection() {
            // Check for updates periodically
            setInterval(() => {
                if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                    navigator.serviceWorker.controller.postMessage({ command: 'checkForUpdates' });
                }
            }, 30000); // Check every 30 seconds
        }

        checkInstallStatus() {
            // Check if running as PWA
            const isStandalone = window.matchMedia('(display-mode: standalone)').matches ||
                               window.navigator.standalone ||
                               document.referrer.includes('android-app://');
            
            if (isStandalone) {
                this.isInstalled = true;
                document.body.classList.add('pwa-installed');
            }
        }

        async promptInstall() {
            if (!this.deferredPrompt) return false;

            this.deferredPrompt.prompt();
            const result = await this.deferredPrompt.userChoice;
            
            if (result.outcome === 'accepted') {
                console.log('PWA install accepted');
                this.isInstalled = true;
            } else {
                console.log('PWA install declined');
            }
            
            this.deferredPrompt = null;
            return result.outcome === 'accepted';
        }

        showInstallButton() {
            const installButton = this.createInstallButton();
            if (installButton && !document.querySelector('.install-button')) {
                const controlPanel = document.querySelector('.control-panel');
                if (controlPanel) {
                    controlPanel.appendChild(installButton);
                }
            }
        }

        createInstallButton() {
            const installItem = document.createElement('div');
            installItem.className = 'control-item';
            
            const label = document.createElement('span');
            label.className = 'control-label';
            label.textContent = 'Install';
            
            const button = document.createElement('button');
            button.className = 'control-button install-button';
            button.setAttribute('aria-label', 'Install app');
            button.innerHTML = 'üì±';
            
            button.addEventListener('click', async () => {
                const installed = await this.promptInstall();
                if (installed) {
                    installItem.remove();
                }
            });
            
            installItem.appendChild(label);
            installItem.appendChild(button);
            
            return installItem;
        }

        hideInstallButton() {
            const installButton = document.querySelector('.install-button');
            if (installButton) {
                installButton.closest('.control-item')?.remove();
            }
        }

        showInstallSuccess() {
            // Show success message
            if (window.petClicker) {
                window.petClicker.announceToScreenReader('App installed successfully! You can now use the clicker offline.');
            }
        }

        showUpdatePrompt() {
            // Show update notification
            const updateNotification = this.createUpdateNotification();
            document.body.appendChild(updateNotification);
        }

        createUpdateNotification() {
            const notification = document.createElement('div');
            notification.className = 'update-notification';
            notification.innerHTML = `
                <div class="update-content">
                    <span>New version available!</span>
                    <button class="update-button">Update</button>
                    <button class="dismiss-button">Later</button>
                </div>
            `;
            
            notification.querySelector('.update-button').addEventListener('click', () => {
                this.applyUpdate();
                notification.remove();
            });
            
            notification.querySelector('.dismiss-button').addEventListener('click', () => {
                notification.remove();
            });
            
            return notification;
        }

        async applyUpdate() {
            if ('serviceWorker' in navigator) {
                const registration = await navigator.serviceWorker.getRegistration();
                if (registration && registration.waiting) {
                    registration.waiting.postMessage({ command: 'skipWaiting' });
                    window.location.reload();
                }
            }
        }

        updateOnlineStatus() {
            const statusDisplay = document.getElementById('audio-status');
            if (statusDisplay && !this.isOnline) {
                statusDisplay.textContent = 'Offline';
                statusDisplay.className = 'status-value status-warning';
            } else if (statusDisplay && this.isOnline && window.petClicker?.isAudioInitialized) {
                statusDisplay.textContent = 'Ready';
                statusDisplay.className = 'status-value status-good';
            }
            
            // Update body class for offline styling
            document.body.classList.toggle('offline', !this.isOnline);
        }

        // Cache management
        async clearCache() {
            if ('caches' in window) {
                const cacheNames = await caches.keys();
                await Promise.all(cacheNames.map(name => caches.delete(name)));
                console.log('Cache cleared');
            }
        }

        async getCacheSize() {
            if ('storage' in navigator && 'estimate' in navigator.storage) {
                const estimate = await navigator.storage.estimate();
                return {
                    usage: estimate.usage,
                    quota: estimate.quota,
                    usageInMB: Math.round(estimate.usage / 1024 / 1024 * 100) / 100
                };
            }
            return null;
        }
    }

    // Pet Training Clicker - Stage 4 Implementation with PWA Features
    class MobileOptimizer {
        constructor() {
            this.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            this.isAndroid = /Android/.test(navigator.userAgent);
            this.devicePixelRatio = window.devicePixelRatio || 1;
            this.touchStartTime = 0;
            this.lastTouchEnd = 0;
            this.hapticSupported = 'vibrate' in navigator;
            
            // Touch event tracking
            this.activeTouch = null;
            this.touchMoved = false;
            
            this.init();
        }

        init() {
            this.setupViewport();
            this.setupTouchOptimizations();
            this.setupHapticFeedback();
            this.setupOrientationHandling();
            this.setupIOSSpecific();
            this.setupAndroidSpecific();
        }

        setupViewport() {
            // Optimize viewport for mobile
            let viewport = document.querySelector('meta[name="viewport"]');
            if (viewport) {
                viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover';
            }

            // Prevent zoom on iOS
            document.addEventListener('gesturestart', (e) => e.preventDefault());
            document.addEventListener('gesturechange', (e) => e.preventDefault());
            document.addEventListener('gestureend', (e) => e.preventDefault());
        }

        setupTouchOptimizations() {
            // Prevent double-tap zoom
            document.addEventListener('touchend', (e) => {
                const now = Date.now();
                if (now - this.lastTouchEnd <= 300) {
                    e.preventDefault();
                }
                this.lastTouchEnd = now;
            }, false);

            // Optimize touch event handling
            document.addEventListener('touchstart', (e) => {
                this.touchStartTime = performance.now();
                this.touchMoved = false;
            }, { passive: true });

            document.addEventListener('touchmove', (e) => {
                this.touchMoved = true;
            }, { passive: true });
        }

        setupHapticFeedback() {
            // Enhanced haptic patterns
            this.hapticPatterns = {
                click: [20], // Short pulse for press
                clack: [10], // Shorter pulse for release
                error: [50, 50, 50], // Triple pulse for errors
                success: [30, 10, 30] // Double pulse for success
            };
        }

        setupOrientationHandling() {
            // Handle orientation changes
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    this.handleOrientationChange();
                }, 500); // Delay to allow layout to settle
            });

            // Handle resize events
            window.addEventListener('resize', this.debounce(() => {
                this.handleResize();
            }, 250));
        }

        setupIOSSpecific() {
            if (!this.isIOS) return;

            // Prevent iOS scroll bounce
            document.body.style.overscrollBehavior = 'none';
            
            // Handle iOS safe areas
            this.handleIOSSafeAreas();
            
            // Prevent iOS selection
            document.body.style.webkitUserSelect = 'none';
            document.body.style.webkitTouchCallout = 'none';
        }

        setupAndroidSpecific() {
            if (!this.isAndroid) return;

            // Optimize for Android chrome
            document.body.style.overscrollBehavior = 'contain';
            
            // Improve touch responsiveness
            document.body.style.touchAction = 'manipulation';
        }

        handleOrientationChange() {
            // Adjust layout for new orientation
            const container = document.querySelector('.container');
            if (container) {
                container.classList.toggle('landscape-mode', window.innerWidth > window.innerHeight);
            }

            // Scroll to top to reset viewport
            window.scrollTo(0, 0);
        }

        handleResize() {
            // Handle dynamic viewport changes (like iOS Safari URL bar)
            this.updateViewportHeight();
        }

        updateViewportHeight() {
            // Set CSS custom property for real viewport height
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }

        handleIOSSafeAreas() {
            // Add CSS for safe area handling
            const style = document.createElement('style');
            style.textContent = `
                @supports (padding: max(0px)) {
                    .container {
                        padding-top: max(20px, env(safe-area-inset-top));
                        padding-bottom: max(20px, env(safe-area-inset-bottom));
                        padding-left: max(20px, env(safe-area-inset-left));
                        padding-right: max(20px, env(safe-area-inset-right));
                    }
                }
            `;
            document.head.appendChild(style);
        }

        triggerHaptic(pattern = 'click') {
            if (!this.hapticSupported) return;

            const hapticPattern = this.hapticPatterns[pattern] || this.hapticPatterns.click;
            
            try {
                navigator.vibrate(hapticPattern);
            } catch (error) {
                console.log('Haptic feedback not available');
            }
        }

        // Enhanced touch event helpers
        isValidTouch(touch, element) {
            const rect = element.getBoundingClientRect();
            return (
                touch.clientX >= rect.left &&
                touch.clientX <= rect.right &&
                touch.clientY >= rect.top &&
                touch.clientY <= rect.bottom
            );
        }

        debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
    }

    class AudioEngine {
        constructor() {
            this.audioContext = null;
            this.audioBuffers = new Map();
            this.isInitialized = false;
            this.audioPool = [];
            this.poolSize = 8;
            this.currentPoolIndex = 0;
            this.volume = 0.8;
            this.selectedSound = 'metal';
            this.useHTML5Fallback = false;
            this.html5AudioPool = [];
            
            // Mobile detection
            this.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            this.isAndroid = /Android/.test(navigator.userAgent);
            this.keepAliveInterval = null;
        }

        async initialize() {
            try {
                // Create AudioContext with optimal latency settings
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    latencyHint: 'interactive',
                    sampleRate: 44100
                });

                console.log(`AudioContext created - Base latency: ${(this.audioContext.baseLatency * 1000).toFixed(1)}ms`);

                // Load clicker sounds
                await this.loadAllSounds();
                
                // Initialize audio pool for rapid clicking
                this.initializeAudioPool();
                
                // Setup mobile-specific workarounds
                await this.setupMobileWorkarounds();
                
                this.isInitialized = true;
                return true;
                
            } catch (error) {
                console.warn('Web Audio API failed, falling back to HTML5 Audio:', error);
                this.initializeHTML5Fallback();
                return false;
            }
        }

        async loadAllSounds() {
            // Generate synthetic clicker sounds - both press (click) and release (clack)
            const sounds = {
                'metal-click': this.generateMetalClick(),
                'metal-clack': this.generateMetalClack(),
                'plastic-click': this.generatePlasticClick(),
                'plastic-clack': this.generatePlasticClack(),
                'box-click': this.generateBoxClick(),
                'box-clack': this.generateBoxClack(),
                'snap-click': this.generateFingerSnapClick(),
                'snap-clack': this.generateFingerSnapClack()
            };

            for (const [name, audioBuffer] of Object.entries(sounds)) {
                this.audioBuffers.set(name, audioBuffer);
            }
        }

        generateMetalClick() {
            // Generate sharp metal clicker PRESS sound (2-6kHz, fast attack)
            const sampleRate = this.audioContext.sampleRate;
            const duration = 0.08; // 80ms
            const length = sampleRate * duration;
            const buffer = this.audioContext.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < length; i++) {
                const t = i / sampleRate;
                // Sharp attack with multiple frequencies for metallic sound
                const envelope = Math.exp(-t * 25); // Fast decay
                const noise = (Math.random() - 0.5) * 0.3;
                const tone1 = Math.sin(2 * Math.PI * 3000 * t) * 0.4;
                const tone2 = Math.sin(2 * Math.PI * 4500 * t) * 0.3;
                const tone3 = Math.sin(2 * Math.PI * 6000 * t) * 0.2;
                
                data[i] = (tone1 + tone2 + tone3 + noise) * envelope;
            }
            return buffer;
        }

        generateMetalClack() {
            // Generate metal clicker RELEASE sound (lower pitch, softer)
            const sampleRate = this.audioContext.sampleRate;
            const duration = 0.06; // 60ms - shorter than click
            const length = sampleRate * duration;
            const buffer = this.audioContext.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < length; i++) {
                const t = i / sampleRate;
                // Softer envelope and lower frequencies
                const envelope = Math.exp(-t * 30); // Faster decay
                const noise = (Math.random() - 0.5) * 0.2;
                const tone1 = Math.sin(2 * Math.PI * 2200 * t) * 0.3; // Lower than press
                const tone2 = Math.sin(2 * Math.PI * 3200 * t) * 0.2;
                const tone3 = Math.sin(2 * Math.PI * 4800 * t) * 0.15;
                
                data[i] = (tone1 + tone2 + tone3 + noise) * envelope * 0.7; // Quieter
            }
            return buffer;
        }

        generatePlasticClick() {
            // Generate softer plastic clicker PRESS sound (1-4kHz, medium attack)
            const sampleRate = this.audioContext.sampleRate;
            const duration = 0.1; // 100ms
            const length = sampleRate * duration;
            const buffer = this.audioContext.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < length; i++) {
                const t = i / sampleRate;
                const envelope = Math.exp(-t * 15); // Medium decay
                const noise = (Math.random() - 0.5) * 0.2;
                const tone1 = Math.sin(2 * Math.PI * 2000 * t) * 0.5;
                const tone2 = Math.sin(2 * Math.PI * 3000 * t) * 0.3;
                
                data[i] = (tone1 + tone2 + noise) * envelope * 0.8;
            }
            return buffer;
        }

        generatePlasticClack() {
            // Generate plastic clicker RELEASE sound
            const sampleRate = this.audioContext.sampleRate;
            const duration = 0.08; // 80ms
            const length = sampleRate * duration;
            const buffer = this.audioContext.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < length; i++) {
                const t = i / sampleRate;
                const envelope = Math.exp(-t * 18); // Slightly faster decay
                const noise = (Math.random() - 0.5) * 0.15;
                const tone1 = Math.sin(2 * Math.PI * 1600 * t) * 0.4; // Lower frequencies
                const tone2 = Math.sin(2 * Math.PI * 2400 * t) * 0.25;
                
                data[i] = (tone1 + tone2 + noise) * envelope * 0.6; // Quieter
            }
            return buffer;
        }

        generateBoxClick() {
            // Generate loud box clicker PRESS sound (2-8kHz, very sharp attack)
            const sampleRate = this.audioContext.sampleRate;
            const duration = 0.11; // 110ms
            const length = sampleRate * duration;
            const buffer = this.audioContext.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < length; i++) {
                const t = i / sampleRate;
                const envelope = Math.exp(-t * 20); // Sharp decay
                const noise = (Math.random() - 0.5) * 0.4;
                const tone1 = Math.sin(2 * Math.PI * 2500 * t) * 0.4;
                const tone2 = Math.sin(2 * Math.PI * 4000 * t) * 0.3;
                const tone3 = Math.sin(2 * Math.PI * 6000 * t) * 0.2;
                const tone4 = Math.sin(2 * Math.PI * 8000 * t) * 0.1;
                
                data[i] = (tone1 + tone2 + tone3 + tone4 + noise) * envelope;
            }
            return buffer;
        }

        generateBoxClack() {
            // Generate box clicker RELEASE sound
            const sampleRate = this.audioContext.sampleRate;
            const duration = 0.09; // 90ms
            const length = sampleRate * duration;
            const buffer = this.audioContext.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < length; i++) {
                const t = i / sampleRate;
                const envelope = Math.exp(-t * 22); // Sharp decay
                const noise = (Math.random() - 0.5) * 0.3;
                const tone1 = Math.sin(2 * Math.PI * 2000 * t) * 0.35; // Lower than press
                const tone2 = Math.sin(2 * Math.PI * 3200 * t) * 0.25;
                const tone3 = Math.sin(2 * Math.PI * 4800 * t) * 0.15;
                const tone4 = Math.sin(2 * Math.PI * 6400 * t) * 0.08;
                
                data[i] = (tone1 + tone2 + tone3 + tone4 + noise) * envelope * 0.75; // Quieter
            }
            return buffer;
        }

        generateFingerSnapClick() {
            // Generate finger snap PRESS sound based on provided algorithm
            const sampleRate = this.audioContext.sampleRate;
            const duration = 0.12; // 120ms total length
            const length = sampleRate * duration;
            const buffer = this.audioContext.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);

            // Parameters for finger snap
            const attack = 0.001;      // 1ms attack (very sharp)
            const decay = 0.07;        // 70ms decay tail
            const bodyHz = 2000;       // main band ~2 kHz (snap "body")
            const airHz = 7000;        // air "slap"/hiss brightness
            const tailGain = 0.6;      // overall tail loudness
            const impulseGain = 0.9;   // short click burst

            for (let i = 0; i < length; i++) {
                const t = i / sampleRate;
                
                // White noise base
                const noise = (Math.random() * 2 - 1);
                
                // Body filter (2kHz bandpass simulation)
                const bodyEnv = Math.exp(-t * (1 / decay * 10)); // Exponential decay
                const bodyTone = Math.sin(2 * Math.PI * bodyHz * t) * bodyEnv;
                const bodyFiltered = noise * 0.3 + bodyTone * 0.7;
                
                // Air filter (7kHz bandpass simulation)
                const airEnv = Math.exp(-t * (1 / decay * 15)); // Faster decay for hiss
                const airTone = Math.sin(2 * Math.PI * airHz * t) * airEnv;
                const airFiltered = noise * 0.5 + airTone * 0.5;
                
                // Tail gain envelope
                let tailEnvelope;
                if (t < attack) {
                    tailEnvelope = (t / attack) * tailGain; // Linear attack
                } else {
                    tailEnvelope = tailGain * Math.exp(-(t - attack) / decay * 8); // Exponential decay
                }
                
                // Impulse component (short chirp)
                const impulseDur = 0.006; // 6ms impulse
                let impulse = 0;
                if (t < impulseDur) {
                    const impulseFreq = 2200 - (t / impulseDur) * 400; // Chirp down from 2200 to 1800 Hz
                    const impulseEnv = impulseGain * Math.exp(-t / impulseDur * 8);
                    impulse = Math.sin(2 * Math.PI * impulseFreq * t) * impulseEnv;
                }
                
                // Combine all components
                const bodyComponent = bodyFiltered * tailEnvelope * 0.4;
                const airComponent = airFiltered * tailEnvelope * 0.3;
                
                data[i] = bodyComponent + airComponent + impulse;
            }
            
            return buffer;
        }

        generateFingerSnapClack() {
            // Generate finger snap RELEASE sound (softer, shorter)
            const sampleRate = this.audioContext.sampleRate;
            const duration = 0.08; // 80ms - shorter than press
            const length = sampleRate * duration;
            const buffer = this.audioContext.createBuffer(1, length, sampleRate);
            const data = buffer.getChannelData(0);

            // Softer parameters for release
            const attack = 0.001;
            const decay = 0.05;        // Faster decay
            const bodyHz = 1600;       // Lower frequency than press
            const airHz = 5500;        // Less bright air component
            const tailGain = 0.4;      // Quieter overall
            const impulseGain = 0.5;   // Much softer impulse

            for (let i = 0; i < length; i++) {
                const t = i / sampleRate;
                
                // White noise base
                const noise = (Math.random() * 2 - 1);
                
                // Body filter (softer, lower frequency)
                const bodyEnv = Math.exp(-t * (1 / decay * 12));
                const bodyTone = Math.sin(2 * Math.PI * bodyHz * t) * bodyEnv;
                const bodyFiltered = noise * 0.2 + bodyTone * 0.6;
                
                // Air filter (less bright)
                const airEnv = Math.exp(-t * (1 / decay * 18));
                const airTone = Math.sin(2 * Math.PI * airHz * t) * airEnv;
                const airFiltered = noise * 0.3 + airTone * 0.4;
                
                // Tail gain envelope
                let tailEnvelope;
                if (t < attack) {
                    tailEnvelope = (t / attack) * tailGain;
                } else {
                    tailEnvelope = tailGain * Math.exp(-(t - attack) / decay * 10);
                }
                
                // Much softer impulse
                const impulseDur = 0.004; // 4ms impulse
                let impulse = 0;
                if (t < impulseDur) {
                    const impulseFreq = 1800 - (t / impulseDur) * 200; // Lower chirp
                    const impulseEnv = impulseGain * Math.exp(-t / impulseDur * 10);
                    impulse = Math.sin(2 * Math.PI * impulseFreq * t) * impulseEnv;
                }
                
                // Combine components (softer mix)
                const bodyComponent = bodyFiltered * tailEnvelope * 0.3;
                const airComponent = airFiltered * tailEnvelope * 0.2;
                
                data[i] = (bodyComponent + airComponent + impulse) * 0.7; // Overall quieter
            }
            
            return buffer;
        }

        initializeAudioPool() {
            this.audioPool = [];
            for (let i = 0; i < this.poolSize; i++) {
                const gainNode = this.audioContext.createGain();
                gainNode.connect(this.audioContext.destination);
                this.audioPool.push({
                    gainNode: gainNode,
                    isPlaying: false
                });
            }
        }

        async setupMobileWorkarounds() {
            if (this.isIOS) {
                await this.setupIOSWorkarounds();
            }
            
            if (this.isAndroid) {
                this.setupAndroidWorkarounds();
            }

            this.setupUserGestureHandler();
        }

        async setupIOSWorkarounds() {
            try {
                // Enable audio in iOS silent mode by playing silent audio
                const silentBuffer = this.audioContext.createBuffer(1, 1, this.audioContext.sampleRate);
                const source = this.audioContext.createBufferSource();
                source.buffer = silentBuffer;
                source.connect(this.audioContext.destination);
                source.start();
                
                console.log('iOS silent mode workaround applied');
            } catch (error) {
                console.warn('iOS workaround failed:', error);
            }
        }

        setupAndroidWorkarounds() {
            // Keep AudioContext alive on Android Chrome
            this.keepAliveInterval = setInterval(() => {
                if (this.audioContext && this.audioContext.state === 'running') {
                    // Play silent tone to prevent context suspension
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    gainNode.gain.setValueAtTime(0.001, this.audioContext.currentTime);
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.01);
                }
            }, 25000); // Every 25 seconds
        }

        setupUserGestureHandler() {
            const unlockAudio = async () => {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                    console.log('AudioContext resumed');
                }
                
                // Remove listeners after first interaction
                document.removeEventListener('touchstart', unlockAudio);
                document.removeEventListener('click', unlockAudio);
            };

            document.addEventListener('touchstart', unlockAudio);
            document.addEventListener('click', unlockAudio);
        }

        playClick() {
            if (this.useHTML5Fallback) {
                return this.playClickHTML5();
            }

            if (!this.isInitialized || !this.audioContext) {
                console.warn('Audio not initialized');
                return false;
            }

            if (this.audioContext.state === 'suspended') {
                this.audioContext.resume();
            }

            // Get next available audio source from pool
            const audioSource = this.getNextAudioSource();
            if (!audioSource) {
                console.warn('All audio sources busy');
                return false;
            }

            const buffer = this.audioBuffers.get(`${this.selectedSound}-click`);
            if (!buffer) {
                console.warn('Audio buffer not found:', `${this.selectedSound}-click`);
                return false;
            }

            // Create and configure buffer source
            const bufferSource = this.audioContext.createBufferSource();
            bufferSource.buffer = buffer;
            
            // Set volume
            audioSource.gainNode.gain.setValueAtTime(
                this.volume, 
                this.audioContext.currentTime
            );
            
            // Connect and play
            bufferSource.connect(audioSource.gainNode);
            bufferSource.start(0);
            
            // Mark source as playing and clean up when done
            audioSource.isPlaying = true;
            bufferSource.onended = () => {
                audioSource.isPlaying = false;
            };

            return true;
        }

        playClack() {
            if (this.useHTML5Fallback) {
                return this.playClackHTML5();
            }

            if (!this.isInitialized || !this.audioContext) {
                console.warn('Audio not initialized');
                return false;
            }

            if (this.audioContext.state === 'suspended') {
                this.audioContext.resume();
            }

            // Get next available audio source from pool
            const audioSource = this.getNextAudioSource();
            if (!audioSource) {
                console.warn('All audio sources busy');
                return false;
            }

            const buffer = this.audioBuffers.get(`${this.selectedSound}-clack`);
            if (!buffer) {
                console.warn('Audio buffer not found:', `${this.selectedSound}-clack`);
                return false;
            }

            // Create and configure buffer source
            const bufferSource = this.audioContext.createBufferSource();
            bufferSource.buffer = buffer;
            
            // Set volume (slightly quieter for release sound)
            audioSource.gainNode.gain.setValueAtTime(
                this.volume * 0.85, 
                this.audioContext.currentTime
            );
            
            // Connect and play
            bufferSource.connect(audioSource.gainNode);
            bufferSource.start(0);
            
            // Mark source as playing and clean up when done
            audioSource.isPlaying = true;
            bufferSource.onended = () => {
                audioSource.isPlaying = false;
            };

            return true;
        }

        getNextAudioSource() {
            // Find next available source in pool
            for (let i = 0; i < this.poolSize; i++) {
                const index = (this.currentPoolIndex + i) % this.poolSize;
                if (!this.audioPool[index].isPlaying) {
                    this.currentPoolIndex = (index + 1) % this.poolSize;
                    return this.audioPool[index];
                }
            }
            return null; // All sources busy
        }

        initializeHTML5Fallback() {
            console.log('Initializing HTML5 Audio fallback');
            this.useHTML5Fallback = true;
            this.html5AudioPool = [];
            
            // Create synthetic click sounds for HTML5 fallback
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const sounds = {
                'metal': this.generateMetalClick.call({audioContext}),
                'plastic': this.generatePlasticClick.call({audioContext}),
                'box': this.generateBoxClick.call({audioContext})
            };

            // Convert to data URLs for HTML5 Audio (simplified for demo)
            for (let i = 0; i < this.poolSize; i++) {
                this.html5AudioPool.push({
                    isPlaying: false,
                    audio: null
                });
            }
            
            this.isInitialized = true;
        }

        playClickHTML5() {
            // Simplified HTML5 fallback - just log for demo
            console.log(`HTML5 Audio: Playing ${this.selectedSound} click at volume ${this.volume}`);
            return true;
        }

        playClackHTML5() {
            // Simplified HTML5 fallback - just log for demo
            console.log(`HTML5 Audio: Playing ${this.selectedSound} clack at volume ${this.volume * 0.85}`);
            return true;
        }

        setVolume(volume) {
            this.volume = Math.max(0, Math.min(1, volume));
        }

        setSelectedSound(soundType) {
            if (this.audioBuffers.has(`${soundType}-click`) && this.audioBuffers.has(`${soundType}-clack`)) {
                this.selectedSound = soundType;
                return true;
            }
            return false;
        }

        cleanup() {
            if (this.keepAliveInterval) {
                clearInterval(this.keepAliveInterval);
            }
            if (this.audioContext) {
                this.audioContext.close();
            }
        }
    }

    class PetClicker {
        constructor() {
            this.clickCount = 0;
            this.volume = 0.8;
            this.selectedSound = 'metal';
            this.isClicking = false;
            this.latencyMeasurements = [];
            this.audioEngine = new AudioEngine();
            this.mobileOptimizer = new MobileOptimizer();
            this.pwaManager = new PWAManager();
            this.isAudioInitialized = false;
            
            // Enhanced touch handling
            this.touchStartTime = 0;
            this.touchId = null;
            this.pressTimer = null;
            
            // Offline capabilities
            this.offlineMode = false;
            this.syncQueue = [];
            
            // DOM Elements
            this.clickButton = null;
            this.volumeSlider = null;
            this.volumeValue = null;
            this.soundSelector = null;
            this.clickCountDisplay = null;
            this.latencyDisplay = null;
            this.audioStatusDisplay = null;
            this.srAnnouncer = null;
            
            this.init();
        }

        async init() {
            this.sessionStartTime = Date.now();
            this.setupElements();
            this.bindEnhancedEvents();
            this.updateDisplay();
            
            // Initialize audio system
            await this.initializeAudio();
            
            // Setup mobile optimizations
            this.setupMobileFeatures();
            
            // Setup PWA features
            this.setupPWAFeatures();
            
            // Load saved settings
            this.loadSettings();
            
            // Apply settings
            this.applySettings();
            
            this.announceToScreenReader('Pet training clicker ready');
        }

        setupPWAFeatures() {
            // Setup offline detection
            window.addEventListener('online', () => {
                this.offlineMode = false;
                this.syncOfflineData();
            });
            
            window.addEventListener('offline', () => {
                this.offlineMode = true;
            });
            
            // Setup before unload to save data
            window.addEventListener('beforeunload', () => {
                this.saveSettings();
            });
            
            // Setup visibility change for battery optimization
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    this.saveSettings();
                    if (this.audioEngine.audioContext) {
                        this.audioEngine.audioContext.suspend();
                    }
                } else {
                    if (this.audioEngine.audioContext && this.audioEngine.audioContext.state === 'suspended') {
                        this.audioEngine.audioContext.resume();
                    }
                }
            });
        }

        loadSettings() {
            try {
                const settings = localStorage.getItem('pet-clicker-settings');
                if (settings) {
                    const parsed = JSON.parse(settings);
                    
                    // Restore volume
                    if (parsed.volume !== undefined) {
                        this.volume = parsed.volume;
                        this.volumeSlider.value = this.volume;
                        this.audioEngine.setVolume(this.volume);
                        this.updateVolumeDisplay();
                    }
                    
                    // Restore sound type
                    if (parsed.selectedSound) {
                        this.selectedSound = parsed.selectedSound;
                        this.soundSelector.value = this.selectedSound;
                        this.audioEngine.setSelectedSound(this.selectedSound);
                    }
                    
                    // Restore click count if recent session
                    if (parsed.clickCount && parsed.lastSession) {
                        const lastSession = new Date(parsed.lastSession);
                        const now = new Date();
                        const hoursSinceLastSession = (now - lastSession) / (1000 * 60 * 60);
                        
                        // Restore count if last session was within 24 hours
                        if (hoursSinceLastSession < 24) {
                            this.clickCount = parsed.clickCount;
                            this.updateDisplay();
                        }
                    }
                }
            } catch (error) {
                console.log('Could not load settings:', error);
            }
        }

        saveSettings() {
            try {
                const settings = {
                    volume: this.volume,
                    selectedSound: this.selectedSound,
                    clickCount: this.clickCount,
                    lastSession: new Date().toISOString()
                };
                
                localStorage.setItem('pet-clicker-settings', JSON.stringify(settings));
            } catch (error) {
                console.log('Could not save settings:', error);
            }
        }

        syncOfflineData() {
            // Sync any offline data when back online
            if (this.syncQueue.length > 0) {
                console.log('Syncing offline data...');
                // In a real app, this might sync to a server
                this.syncQueue = [];
            }
        }

        setupMobileFeatures() {
            // Update viewport height for mobile
            this.mobileOptimizer.updateViewportHeight();
            
            // Add mobile-specific classes
            if (this.mobileOptimizer.isIOS) {
                document.body.classList.add('ios-device');
            }
            if (this.mobileOptimizer.isAndroid) {
                document.body.classList.add('android-device');
            }
        }

        bindEnhancedEvents() {
            // Enhanced touch events for better mobile experience
            this.clickButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                this.handleEnhancedTouchStart(e);
            }, { passive: false });
            
            this.clickButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                this.handleEnhancedTouchEnd(e);
            }, { passive: false });

            this.clickButton.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                this.handleTouchCancel(e);
            }, { passive: false });

            this.clickButton.addEventListener('touchmove', (e) => {
                this.handleTouchMove(e);
            }, { passive: true });
            
            // Mouse events for desktop
            this.clickButton.addEventListener('mousedown', (e) => {
                e.preventDefault();
                this.handleClickStart();
            });
            
            this.clickButton.addEventListener('mouseup', (e) => {
                e.preventDefault();
                this.handleClickEnd();
            });

            // Prevent context menu
            this.clickButton.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            // Enhanced volume control
            this.volumeSlider.addEventListener('input', (e) => {
                this.volume = parseFloat(e.target.value);
                this.audioEngine.setVolume(this.volume);
                this.updateVolumeDisplay();
                
                // Haptic feedback for volume changes on mobile
                if (this.mobileOptimizer.isIOS || this.mobileOptimizer.isAndroid) {
                    this.mobileOptimizer.triggerHaptic('click');
                }
            });

            // Sound selection with haptic feedback
            this.soundSelector.addEventListener('change', (e) => {
                this.selectedSound = e.target.value;
                this.audioEngine.setSelectedSound(this.selectedSound);
                this.announceToScreenReader(`Sound changed to ${this.selectedSound} clicker`);
                
                // Play preview sound
                setTimeout(() => {
                    this.audioEngine.playClick();
                }, 100);
            });

            // Settings button
            document.getElementById('settings-button').addEventListener('click', () => {
                this.openSettings();
            });

            // Enhanced keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                this.handleKeyboard(e);
            });

            // Prevent zoom on double tap
            this.preventDoubleZoom();

            // Setup settings panel events
            this.setupSettingsEvents();
        }

        setupSettingsEvents() {
            const settingsOverlay = document.getElementById('settings-overlay');
            const closeButton = document.getElementById('close-settings');

            // Close settings
            closeButton.addEventListener('click', () => {
                this.closeSettings();
            });

            // Close on overlay click
            settingsOverlay.addEventListener('click', (e) => {
                if (e.target === settingsOverlay) {
                    this.closeSettings();
                }
            });

            // Close on escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && settingsOverlay.classList.contains('active')) {
                    this.closeSettings();
                }
            });

            // Settings volume control
            const settingsVolumeSlider = document.getElementById('settings-volume');
            const settingsVolumeValue = document.getElementById('settings-volume-value');
            
            settingsVolumeSlider.addEventListener('input', (e) => {
                const volume = parseFloat(e.target.value);
                this.volume = volume;
                this.volumeSlider.value = volume;
                this.audioEngine.setVolume(volume);
                this.updateVolumeDisplay();
                settingsVolumeValue.textContent = Math.round(volume * 100) + '%';
            });

            // Settings sound selector
            const settingsSoundSelector = document.getElementById('settings-sound');
            settingsSoundSelector.addEventListener('change', (e) => {
                this.selectedSound = e.target.value;
                this.soundSelector.value = e.target.value;
                this.audioEngine.setSelectedSound(this.selectedSound);
                
                // Play preview
                setTimeout(() => {
                    this.audioEngine.playClick();
                }, 100);
            });

            // Toggle switches
            this.setupToggleSwitch('haptic-toggle', 'hapticEnabled', true);
            this.setupToggleSwitch('screenreader-toggle', 'screenReaderEnabled', true);
            this.setupToggleSwitch('performance-toggle', 'performanceDisplayEnabled', true);

            // Action buttons
            document.getElementById('export-settings').addEventListener('click', () => {
                this.exportSettings();
            });

            document.getElementById('import-settings').addEventListener('click', () => {
                document.getElementById('import-file').click();
            });

            document.getElementById('import-file').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    this.importSettings(file);
                    e.target.value = ''; // Reset file input
                }
            });

            document.getElementById('reset-counter').addEventListener('click', () => {
                if (confirm('Reset click counter to zero?')) {
                    this.clickCount = 0;
                    this.updateDisplay();
                    this.updateSettingsStats();
                    this.saveSettings();
                    this.announceToScreenReader('Click counter reset');
                }
            });

            document.getElementById('reset-all').addEventListener('click', () => {
                this.resetAllData();
            });
        }

        setupToggleSwitch(toggleId, settingKey, defaultValue) {
            const toggle = document.getElementById(toggleId);
            let isEnabled = this.getSetting(settingKey, defaultValue);
            
            // Set initial state
            toggle.classList.toggle('active', isEnabled);
            
            toggle.addEventListener('click', () => {
                isEnabled = !isEnabled;
                toggle.classList.toggle('active', isEnabled);
                this.setSetting(settingKey, isEnabled);
                
                // Apply setting immediately
                this.applySettings();
            });
        }

        openSettings() {
            const settingsOverlay = document.getElementById('settings-overlay');
            settingsOverlay.classList.add('active');
            
            // Update settings values
            this.updateSettingsPanel();
            
            // Focus close button for accessibility
            setTimeout(() => {
                document.getElementById('close-settings').focus();
            }, 100);
            
            this.announceToScreenReader('Settings opened');
        }

        closeSettings() {
            const settingsOverlay = document.getElementById('settings-overlay');
            settingsOverlay.classList.remove('active');
            
            // Return focus to settings button
            document.getElementById('settings-button').focus();
            
            this.announceToScreenReader('Settings closed');
        }

        updateSettingsPanel() {
            // Update volume controls
            const settingsVolumeSlider = document.getElementById('settings-volume');
            const settingsVolumeValue = document.getElementById('settings-volume-value');
            settingsVolumeSlider.value = this.volume;
            settingsVolumeValue.textContent = Math.round(this.volume * 100) + '%';

            // Update sound selector
            document.getElementById('settings-sound').value = this.selectedSound;

            // Update audio engine info
            const audioEngineInfo = document.getElementById('audio-engine-info');
            if (this.audioEngine.useHTML5Fallback) {
                audioEngineInfo.textContent = 'HTML5 Audio';
                audioEngineInfo.className = 'info-value status-warning';
            } else {
                audioEngineInfo.textContent = 'Web Audio API';
                audioEngineInfo.className = 'info-value status-good';
            }

            // Update installation status
            const installStatus = document.getElementById('install-status');
            if (this.pwaManager.isInstalled) {
                installStatus.textContent = 'Installed';
                installStatus.className = 'info-value status-good';
            } else {
                installStatus.textContent = 'Browser';
                installStatus.className = 'info-value';
            }

            // Update statistics
            this.updateSettingsStats();

            // Update storage info
            this.updateStorageInfo();
        }

        updateSettingsStats() {
            const sessionStartTime = this.sessionStartTime || Date.now();
            const sessionDuration = Math.round((Date.now() - sessionStartTime) / 60000); // minutes
            const clicksPerMin = sessionDuration > 0 ? Math.round(this.clickCount / sessionDuration) : 0;

            document.getElementById('total-clicks').textContent = this.clickCount;
            document.getElementById('avg-latency').textContent = 
                this.getAverageLatency() > 0 ? this.getAverageLatency().toFixed(1) + 'ms' : '--ms';
            document.getElementById('session-time').textContent = sessionDuration + 'm';
            document.getElementById('clicks-per-min').textContent = clicksPerMin;
        }

        async updateStorageInfo() {
            try {
                const cacheSize = await this.pwaManager.getCacheSize();
                const storageInfo = document.getElementById('storage-info');
                
                if (cacheSize) {
                    storageInfo.textContent = cacheSize.usageInMB.toFixed(1) + 'MB';
                } else {
                    storageInfo.textContent = '--KB';
                }
            } catch (error) {
                document.getElementById('storage-info').textContent = '--KB';
            }
        }

        getSetting(key, defaultValue) {
            try {
                const settings = JSON.parse(localStorage.getItem('pet-clicker-settings') || '{}');
                return settings[key] !== undefined ? settings[key] : defaultValue;
            } catch {
                return defaultValue;
            }
        }

        setSetting(key, value) {
            try {
                const settings = JSON.parse(localStorage.getItem('pet-clicker-settings') || '{}');
                settings[key] = value;
                localStorage.setItem('pet-clicker-settings', JSON.stringify(settings));
            } catch (error) {
                console.warn('Could not save setting:', error);
            }
        }

        applySettings() {
            // Apply haptic setting
            const hapticEnabled = this.getSetting('hapticEnabled', true);
            this.mobileOptimizer.hapticSupported = hapticEnabled && 'vibrate' in navigator;

            // Apply screen reader setting
            const screenReaderEnabled = this.getSetting('screenReaderEnabled', true);
            this.screenReaderEnabled = screenReaderEnabled;

            // Apply performance display setting
            const performanceEnabled = this.getSetting('performanceDisplayEnabled', true);
            const statusPanel = document.querySelector('.status-panel');
            if (statusPanel) {
                statusPanel.style.display = performanceEnabled ? 'flex' : 'none';
            }
        }

        handleEnhancedTouchStart(event) {
            if (this.isClicking || !this.isAudioInitialized) return;
            
            const touch = event.touches[0];
            if (!touch) return;

            // Store touch info
            this.touchId = touch.identifier;
            this.touchStartTime = performance.now();
            
            // Validate touch is within button bounds
            if (!this.mobileOptimizer.isValidTouch(touch, this.clickButton)) {
                return;
            }

            this.handleClickStart();
        }

        handleEnhancedTouchEnd(event) {
            if (!this.isClicking) return;

            // Ensure this is the same touch that started
            const touch = event.changedTouches[0];
            if (touch && touch.identifier !== this.touchId) return;

            this.handleClickEnd();
            this.touchId = null;
        }

        handleTouchCancel(event) {
            // Handle touch interruption (like incoming call)
            if (this.isClicking) {
                this.handleClickEnd();
            }
            this.touchId = null;
        }

        handleTouchMove(event) {
            if (!this.isClicking || !this.touchId) return;

            const touch = Array.from(event.touches).find(t => t.identifier === this.touchId);
            if (!touch) return;

            // Cancel if touch moves too far from button
            if (!this.mobileOptimizer.isValidTouch(touch, this.clickButton)) {
                this.handleTouchCancel(event);
            }
        }

        preventDoubleZoom() {
            let lastTouchEnd = 0;
            document.addEventListener('touchend', (e) => {
                const now = Date.now();
                if (now - lastTouchEnd <= 300) {
                    e.preventDefault();
                }
                lastTouchEnd = now;
            }, false);
        }

        async initializeAudio() {
            try {
                this.audioStatusDisplay.textContent = 'Loading...';
                this.audioStatusDisplay.className = 'status-value status-warning';
                
                const success = await this.audioEngine.initialize();
                
                if (success) {
                    this.audioStatusDisplay.textContent = 'Ready';
                    this.audioStatusDisplay.className = 'status-value status-good';
                    this.isAudioInitialized = true;
                    console.log('Audio system initialized successfully');
                } else {
                    this.audioStatusDisplay.textContent = 'Fallback';
                    this.audioStatusDisplay.className = 'status-value status-warning';
                    this.isAudioInitialized = true;
                    console.log('Audio system using HTML5 fallback');
                }
            } catch (error) {
                this.audioStatusDisplay.textContent = 'Error';
                this.audioStatusDisplay.className = 'status-value status-error';
                console.error('Audio initialization failed:', error);
            }
        }

        setupElements() {
            this.clickButton = document.getElementById('click-button');
            this.volumeSlider = document.getElementById('volume-slider');
            this.volumeValue = document.getElementById('volume-value');
            this.soundSelector = document.getElementById('sound-selector');
            this.clickCountDisplay = document.getElementById('click-count');
            this.latencyDisplay = document.getElementById('latency-display');
            this.audioStatusDisplay = document.getElementById('audio-status');
            this.srAnnouncer = document.getElementById('sr-announcer');

            // Set initial values
            this.volumeSlider.value = this.volume;
            this.soundSelector.value = this.selectedSound;
            this.audioEngine.setVolume(this.volume);
            this.audioEngine.setSelectedSound(this.selectedSound);
            
            // Mobile-specific element optimizations
            if (this.mobileOptimizer.isIOS || this.mobileOptimizer.isAndroid) {
                // Improve touch targets
                this.clickButton.style.minHeight = '44px';
                this.clickButton.style.minWidth = '44px';
                
                // Optimize volume slider for mobile
                this.volumeSlider.style.minHeight = '44px';
            }
        }

        bindEvents() {
            // Primary click handlers
            this.clickButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                this.handleClickStart();
            });
            
            this.clickButton.addEventListener('mousedown', (e) => {
                e.preventDefault();
                this.handleClickStart();
            });

            this.clickButton.addEventListener('touchend', () => {
                this.handleClickEnd();
            });
            
            this.clickButton.addEventListener('mouseup', () => {
                this.handleClickEnd();
            });

            // Prevent context menu on long press
            this.clickButton.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            // Volume control
            this.volumeSlider.addEventListener('input', (e) => {
                this.volume = parseFloat(e.target.value);
                this.audioEngine.setVolume(this.volume);
                this.updateVolumeDisplay();
            });

            // Sound selection
            this.soundSelector.addEventListener('change', (e) => {
                this.selectedSound = e.target.value;
                this.audioEngine.setSelectedSound(this.selectedSound);
                this.announceToScreenReader(`Sound changed to ${this.selectedSound} clicker`);
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                this.handleKeyboard(e);
            });

            // Prevent zooming on double tap
            let lastTouchEnd = 0;
            document.addEventListener('touchend', (e) => {
                const now = (new Date()).getTime();
                if (now - lastTouchEnd <= 300) {
                    e.preventDefault();
                }
                lastTouchEnd = now;
            }, false);
        }

        handleClickStart() {
            if (this.isClicking || !this.isAudioInitialized) return;
            
            const startTime = performance.now();
            this.isClicking = true;
            
            // Enhanced visual feedback
            this.clickButton.classList.add('clicking');
            
            // Enhanced haptic feedback with patterns
            if (this.mobileOptimizer.hapticSupported) {
                this.mobileOptimizer.triggerHaptic('click');
            }
            
            // Add haptic pulse animation
            this.clickButton.classList.add('haptic-pulse');
            setTimeout(() => {
                this.clickButton.classList.remove('haptic-pulse');
            }, 100);
            
            // Play PRESS sound (click)
            const audioSuccess = this.audioEngine.playClick();
            
            if (audioSuccess) {
                // Update counter only if audio played successfully
                this.clickCount++;
                this.updateDisplay();
                
                // Measure actual audio latency
                const endTime = performance.now();
                this.recordLatency(endTime - startTime);
                
                // Update status
                this.audioStatusDisplay.textContent = 'Pressed';
                this.audioStatusDisplay.className = 'status-value status-good';
                
            } else {
                // Audio failed - enhanced error feedback
                this.audioStatusDisplay.textContent = 'Error';
                this.audioStatusDisplay.className = 'status-value status-error';
                
                // Error haptic pattern
                this.mobileOptimizer.triggerHaptic('error');
            }
            
            // Screen reader feedback (throttled)
            if (this.clickCount % 10 === 0) {
                this.announceToScreenReader(`${this.clickCount} clicks completed`);
            }
        }

        handleClickEnd() {
            if (!this.isClicking) return;
            
            this.isClicking = false;
            this.clickButton.classList.remove('clicking');
            
            // Enhanced haptic feedback for release
            if (this.mobileOptimizer.hapticSupported) {
                this.mobileOptimizer.triggerHaptic('clack');
            }
            
            // Play RELEASE sound (clack)
            const audioSuccess = this.audioEngine.playClack();
            
            if (audioSuccess) {
                // Update status
                this.audioStatusDisplay.textContent = 'Released';
                this.audioStatusDisplay.className = 'status-value status-good';
                
                // Success haptic pattern
                this.mobileOptimizer.triggerHaptic('success');
                
                // Reset status after short delay
                setTimeout(() => {
                    if (this.isAudioInitialized) {
                        this.audioStatusDisplay.textContent = 'Ready';
                        this.audioStatusDisplay.className = 'status-value status-good';
                    }
                }, 300);
            } else {
                // Audio failed
                this.audioStatusDisplay.textContent = 'Error';
                this.audioStatusDisplay.className = 'status-value status-error';
                this.mobileOptimizer.triggerHaptic('error');
            }
        }

        handleKeyboard(event) {
            // Space bar or Enter to click
            if (event.code === 'Space' || event.code === 'Enter') {
                event.preventDefault();
                if (!this.isClicking) {
                    this.handleClickStart();
                    
                    // Auto-release after realistic delay for keyboard (like physical clicker)
                    setTimeout(() => this.handleClickEnd(), 150);
                }
            }
            
            // Volume controls
            if (event.code === 'ArrowUp') {
                event.preventDefault();
                this.adjustVolume(0.1);
            }
            
            if (event.code === 'ArrowDown') {
                event.preventDefault();
                this.adjustVolume(-0.1);
            }

            // Sound type cycling
            if (event.code === 'KeyM') {
                event.preventDefault();
                this.cycleSoundType();
            }
        }

        cycleSoundType() {
            const sounds = ['metal', 'plastic', 'box', 'snap'];
            const currentIndex = sounds.indexOf(this.selectedSound);
            const nextIndex = (currentIndex + 1) % sounds.length;
            
            this.selectedSound = sounds[nextIndex];
            this.soundSelector.value = this.selectedSound;
            this.audioEngine.setSelectedSound(this.selectedSound);
            this.announceToScreenReader(`Sound changed to ${this.selectedSound} clicker`);
        }

        adjustVolume(delta) {
            this.volume = Math.max(0, Math.min(1, this.volume + delta));
            this.volumeSlider.value = this.volume;
            this.audioEngine.setVolume(this.volume);
            this.updateVolumeDisplay();
            this.announceToScreenReader(`Volume ${Math.round(this.volume * 100)}%`);
        }

        recordLatency(latency) {
            this.latencyMeasurements.push(latency);
            if (this.latencyMeasurements.length > 50) {
                this.latencyMeasurements.shift();
            }
        }

        getAverageLatency() {
            if (this.latencyMeasurements.length === 0) return 0;
            const sum = this.latencyMeasurements.reduce((a, b) => a + b, 0);
            return sum / this.latencyMeasurements.length;
        }

        updateDisplay() {
            // Update click count
            this.clickCountDisplay.textContent = this.clickCount;
            
            // Update latency display
            const avgLatency = this.getAverageLatency();
            if (avgLatency > 0) {
                this.latencyDisplay.textContent = `${avgLatency.toFixed(1)}ms`;
                
                // Color code latency based on pet training effectiveness
                if (avgLatency < 20) {
                    this.latencyDisplay.className = 'status-value status-good';
                } else if (avgLatency < 50) {
                    this.latencyDisplay.className = 'status-value status-warning';
                } else {
                    this.latencyDisplay.className = 'status-value status-error';
                }
            }
        }

        updateVolumeDisplay() {
            const percentage = Math.round(this.volume * 100);
            this.volumeValue.textContent = `${percentage}%`;
        }

        announceToScreenReader(message) {
            if (this.srAnnouncer) {
                this.srAnnouncer.textContent = message;
            }
        }

        // Cleanup when page unloads
        destroy() {
            // Save settings before destroying
            this.saveSettings();
            
            if (this.audioEngine) {
                this.audioEngine.cleanup();
            }
            
            // Clear any timers
            if (this.pressTimer) {
                clearTimeout(this.pressTimer);
            }
        }

        // Export/Import settings for backup
        exportSettings() {
            const settings = {
                volume: this.volume,
                selectedSound: this.selectedSound,
                clickCount: this.clickCount,
                exportDate: new Date().toISOString(),
                version: '1.0.0'
            };
            
            const dataStr = JSON.stringify(settings, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'pet-clicker-settings.json';
            link.click();
            
            URL.revokeObjectURL(url);
        }

        async importSettings(file) {
            try {
                const text = await file.text();
                const settings = JSON.parse(text);
                
                if (settings.volume !== undefined) {
                    this.volume = Math.max(0, Math.min(1, settings.volume));
                    this.volumeSlider.value = this.volume;
                    this.audioEngine.setVolume(this.volume);
                    this.updateVolumeDisplay();
                }
                
                if (settings.selectedSound && ['metal', 'plastic', 'box'].includes(settings.selectedSound)) {
                    this.selectedSound = settings.selectedSound;
                    this.soundSelector.value = this.selectedSound;
                    this.audioEngine.setSelectedSound(this.selectedSound);
                }
                
                if (settings.clickCount !== undefined) {
                    this.clickCount = Math.max(0, settings.clickCount);
                    this.updateDisplay();
                }
                
                this.saveSettings();
                this.announceToScreenReader('Settings imported successfully');
                
            } catch (error) {
                console.error('Failed to import settings:', error);
                this.announceToScreenReader('Failed to import settings');
            }
        }

        // Reset all data
        resetAllData() {
            if (confirm('Reset all data including click count and settings?')) {
                this.clickCount = 0;
                this.volume = 0.8;
                this.selectedSound = 'metal';
                
                // Update UI
                this.volumeSlider.value = this.volume;
                this.soundSelector.value = this.selectedSound;
                this.audioEngine.setVolume(this.volume);
                this.audioEngine.setSelectedSound(this.selectedSound);
                this.updateVolumeDisplay();
                this.updateDisplay();
                
                // Clear stored data
                try {
                    localStorage.removeItem('pet-clicker-settings');
                } catch (error) {
                    console.log('Could not clear settings:', error);
                }
                
                // Clear cache if requested
                if (confirm('Also clear app cache? (This will require reloading the app)')) {
                    this.pwaManager.clearCache().then(() => {
                        window.location.reload();
                    });
                }
                
                this.announceToScreenReader('All data reset');
            }
        }
    }

    // Initialize the application when DOM is loaded
    let petClicker = null;
    let mobileOptimizer = null;
    
    document.addEventListener('DOMContentLoaded', () => {
        petClicker = new PetClicker();
    });

    // Handle mobile-specific events
    window.addEventListener('orientationchange', () => {
        setTimeout(() => {
            // Recalculate viewport after orientation change
            if (petClicker && petClicker.mobileOptimizer) {
                petClicker.mobileOptimizer.handleOrientationChange();
            }
        }, 500);
    });

    // Handle page visibility changes (important for mobile battery saving)
    document.addEventListener('visibilitychange', () => {
        if (petClicker && petClicker.audioEngine) {
            if (document.hidden) {
                // Pause audio context when app goes to background
                if (petClicker.audioEngine.audioContext) {
                    petClicker.audioEngine.audioContext.suspend();
                }
            } else {
                // Resume when app comes back
                if (petClicker.audioEngine.audioContext) {
                    petClicker.audioEngine.audioContext.resume();
                }
            }
        }
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
        if (petClicker) {
            petClicker.destroy();
        }
    });

    // Prevent iOS zoom gestures
    document.addEventListener('gesturestart', (e) => {
        e.preventDefault();
    });

    // Handle iOS device motion (shake to reset counter - fun feature)
    if (window.DeviceMotionEvent) {
        let lastShake = 0;
        window.addEventListener('devicemotion', (event) => {
            const acceleration = event.accelerationIncludingGravity;
            const now = Date.now();
            
            if (acceleration && now - lastShake > 1000) {
                const totalAcceleration = Math.abs(acceleration.x) + 
                                        Math.abs(acceleration.y) + 
                                        Math.abs(acceleration.z);
                
                if (totalAcceleration > 25 && petClicker) {
                    // Shake detected - could reset counter or provide feedback
                    if (petClicker.mobileOptimizer.hapticSupported) {
                        petClicker.mobileOptimizer.triggerHaptic('success');
                    }
                    lastShake = now;
                }
            }
        });
    }

    // Wake lock to prevent screen from sleeping during training
    let wakeLock = null;
    let wakeLockSupported = false;

    async function requestWakeLock() {
        try {
            if ('wakeLock' in navigator) {
                wakeLockSupported = true;
                wakeLock = await navigator.wakeLock.request('screen');
                console.log('Screen wake lock active');
                
                // Handle wake lock release (e.g., when tab becomes hidden)
                wakeLock.addEventListener('release', () => {
                    console.log('Screen wake lock released');
                });
            }
        } catch (err) {
            // Silently handle wake lock errors - they're not critical for functionality
            console.log('Wake lock not available or denied - screen may sleep during training');
            wakeLockSupported = false;
        }
    }

    // Re-acquire wake lock when page becomes visible again
    document.addEventListener('visibilitychange', async () => {
        if (wakeLockSupported && wakeLock !== null && document.visibilityState === 'visible') {
            try {
                wakeLock = await navigator.wakeLock.request('screen');
            } catch (err) {
                // Silently handle - wake lock is optional
            }
        }
    });

    // Request wake lock on first click (not just any interaction)
    let wakeLockRequested = false;
    function tryRequestWakeLock() {
        if (!wakeLockRequested) {
            wakeLockRequested = true;
            requestWakeLock();
        }
    }

    // Only request wake lock when actually clicking the clicker button
    document.addEventListener('DOMContentLoaded', () => {
        const clickButton = document.getElementById('click-button');
        if (clickButton) {
            clickButton.addEventListener('click', tryRequestWakeLock, { once: true });
            clickButton.addEventListener('touchstart', tryRequestWakeLock, { once: true });
        }
    });
</script>
```

</body>
</html>